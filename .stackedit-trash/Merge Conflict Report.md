Changes were detected on both the server and the client.  **The server version was used**.
If you want to use the client or merged version,
paste the content from the desired column from this document into the current document.
This document contains the server, client, and estimated merged content for your records.

# Text Merge Details
Date: 24/03/2022 15:57:20

```json
[Browser Info]
{
  "appVersion": "5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/99.0.4844.51 Safari/537.36 Edg/99.0.1150.39",
  "userAgent": "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/99.0.4844.51 Safari/537.36 Edg/99.0.1150.39",
  "platform": "Win32"
}
```

Document: [design-patterns](/app#id=LOTdUhBII3gXSXb2)

Client Length: 39047

Server Length: 39057

Merge Length: 39053

Client Hash: -2043982587

Server Hash: -692440764

Merge Hash: 1465642059

# Content


|Client|Server|Merge|
|-|-|-|
|# Design Patterns<br /><br />- [Design Patterns](#design-patterns)<br />  * [Creational Design Patterns](#creational-design-patterns)<br />    + [Factory Method](#factory-method)<br />    + [Abstract Factory](#abstract-factory)<br />    + [Builder](#builder)<br />    + [Prototype](#prototype)<br />    + [Singleton](#singleton)<br />      - [Monostate...](#monostate)<br />  * [Structural Design Patterns](#structural-design-patterns)<br />    + [Adapter](#adapter)<br />    + [Bridge](#bridge)<br />    + [Facade](#facade)<br />      - [Law of Demeter (Principle of Least Knowledge)](#law-of-demeter--principle-of-least-knowledge-)<br />    + [Proxy](#proxy)<br />    + [Decorator](#decorator)<br />    + [Composite](#composite)<br />    + [Flyweight](#flyweight)<br />  * [Behavioral Patterns](#behavioral-patterns)<br />    + [Chain of Responsibility](#chain-of-responsibility)<br />    + [Command](#command)<br />    + [Interpreter](#interpreter)<br />    + [Iterator](#iterator)<br />      - [Null Iterator](#null-iterator)<br />    + [Mediator](#mediator)<br />    + [Memento](#memento)<br />    + [State](#state)<br />    + [Observer](#observer)<br />    + [Strategy](#strategy)<br />    + [Template Method](#template-method)<br />    + [Visitor](#visitor)<br />  * [Other Patterns](#other-patterns)<br />    + [Null Object](#null-object)<br />    + [Honorable Mentions](#honorable-mentions)<br /><br /><small><i><a href='http://ecotrust-canada.github.io/markdown-toc/'>Table of contents generated with markdown-toc</a></i></small><br /><br /><br />## Creational Design Patterns<br /><br />###  Factory Method<br /><br />Creates an instance of several derived classes.<br /><br />> *Abstract the instantiation of objects by wrapping them in a Factory method.*<br /><br />**Uses:**<br />- Frameworks<br />- TDD<br /><br />**UML:**<br /><br />![factory-method](https://user-images.githubusercontent.com/72560319/159106269-6a0b440f-ad84-4f1b-bc60-9252db988268.png)<br /><br />**In C#:**<br />```cs<br />public class Program<br />{<br />	public static void Main()<br />	{<br />		var animal1 = new BalancedAnimalFactory().CreateAnimal();<br />		var animal2 = new RandomAnimalFactory().CreateAnimal();<br />	}<br />}<br />	<br />public abstract class Animal { }<br /><br />public class Dog : Animal { }<br />public class Cat : Animal { }<br />public class Duck : Animal { }<br /><br />public interface IAnimalFactory <br />{<br />	public Animal CreateAnimal();<br />}<br /><br />public class BalancedAnimalFactory : IAnimalFactory<br />{<br />	public Animal CreateAnimal()<br />	{<br />		// Logic<br />		return new Dog();<br />	}<br />}<br /><br />public class RandomAnimalFactory : IAnimalFactory<br />{<br />	public Animal CreateAnimal()<br />	{<br />		// Logic<br />		return new Cat();<br />	}<br />}<br />```<br /><br />**In TypeScript:**<br />```ts<br />    function fabricatePerson(name, lastname) {<br />        let person = {}<br />        person.name = name<br />        person.lastname = lastname<br />            <br />        function fullName() {<br />    	    return `${person.name} ${person.lastname}`<br />        }<br /><br />		person.fullName<br />        <br />        return person<br />    }<br />```<br /><br />###  Abstract Factory<br /><br />Create an object without exposing the creation logic to the client and refer to newly created object using a common interface.<br /><br />**Uses:**<br />- UI Controls<br />- Multiplatform Toolkits<br />- Product Families<br /><br />**UML:** <br /><br />![abstract-factory](https://user-images.githubusercontent.com/72560319/159106388-4cc123cf-d58e-4857-8d55-921cf0a3bd78.png)<br /><br />**In C#:**<br />```cs<br />public class Program<br />{<br />	public static void Main()<br />	{<br />		new NavigationBar(new Android());<br />		new DropdownMenu(new Android());<br />	}<br />}<br /><br />public class Button<br />{<br />	public string Type { get; set; }<br />}<br /><br />public interface IUIFactory<br />{<br />	public Button CreateButton();<br />}<br /><br />public class Apple : IUIFactory<br />{<br />	public Button CreateButton()<br />	{<br />		return new Button { Type = "iOS Button".Dump() };<br />	}<br />}<br /><br />public class Android : IUIFactory<br />{<br />	public Button CreateButton()<br />	{<br />		return new Button { Type = "Android Button".Dump() };<br />	}<br />}<br /><br />public class NavigationBar<br />{<br />	public NavigationBar(IUIFactory factory) => factory.CreateButton();<br />}<br /><br />public class DropdownMenu<br />{<br />	public DropdownMenu(IUIFactory factory) => factory.CreateButton();<br />}<br />```<br /><br />**In TypeScript:**<br />```ts<br />    abstract class Animal {}<br />    <br />    abstract class Bird extends Animal {}<br />    <br />    abstract class Reptile extends Animal {}<br />    <br />    class Hawk extends Bird {}<br />    <br />    class Alligator extends Reptile {}<br />```<br /><br />###  Builder<br /><br />Separates object construction from its representation. <br /><br />A `Builder` abstract class or interface and one `ConcreteBuilder` for each variation of the product.<br /><br />**Uses:**<br />- Templates<br />- Text Editors<br /><br />**In TypeScript:**<br />```ts<br />    var Task = (name, description, finished, dueDate) => {<br />        this.name = name<br />        this.description = description<br />        this.finished = finished<br />        this.dueDate = dueDate<br />    }<br />    <br />    var TaskBuilder = () => {    <br />        let name<br />        let description<br />        let isFinished = false<br />        let dueDate<br />    <br />        return {<br />            setName: name => {<br />                this.name = name<br />                return this<br />            },<br />            setDescription: description => {<br />                this.description = description<br />                return this<br />            },<br />            setFinished: finished => {<br />                this.finished = finished<br />                return this<br />            },<br />            setDueDate: dueDate => {<br />                this.dueDate = dueDate<br />                return this<br />            },<br />            build: () => {<br />                return new Task(name, description, isFinished, dueDate)<br />            }<br />        }<br />    }<br />    <br />    let task = new TaskBuilder().setName('Task A').setDescription('finish book')<br />        .setDueDate(new Date(2019, 5, 12))<br />```<br />    <br />###  Prototype<br /><br />A fully initialized instance to be copied or cloned and then modified.<br /><br />**Uses:**<br />- Avoid unnecessary subclasses<br />- JavaScript and TypeScript<br /><br />**In TypeScript:**<br />```ts<br />    interface Prototype {<br />        clone(): Prototype<br />    }<br />    <br />    class Person implements Prototype {<br />        constructor(public name: string, public age: number) {}<br />    	<br />        clone(): this {<br />            const newPerson = Object.create(this)<br />            return newPerson<br />        }<br />    }<br />    <br />    const person1 = new Person('Luiz', 30)<br />    const person2 = person1.clone()<br />```<br /><br />###  Singleton<br /><br />A class of which only a single instance can exist and that provides a global access to itl. <br /><br />All singletons have a private constructor (`createInstance`), a public access method (`getInstance`) and a static attribute (`instance`).<br /><br />> If possible, avoid singletons at all. They can be very tricky to escalate and to work with TDD, as one man's constant is one man's variable.<br /><br />> In a way, it's completely fine to have a single object within an application, but it isn't to make it impossible to create a second instance.<br /><br />**Uses:**<br />- Database Configuration<br /><br />**UML:**<br /><br />![singleton](https://user-images.githubusercontent.com/72560319/159556077-69285a0d-d32d-4b24-ad8f-b8a8a1f301b8.png)<br /><br />**In C#:**<br />```cs<br />class Singleton<br />{<br />    private Singleton() { }<br /><br />    private static Singleton? Instance;<br /><br />    public static void GetInstance()<br />    {<br />        if (Instance == null)<br />            Instance = new Singleton();<br />    }<br />}<br />```<br /><br />**In TypeScript:**<br />```ts<br />    const database = (() => {<br />        var instance<br />    <br />        function createInstance() {<br />            var object = new Object("I am the instance")<br />            return object<br />        }<br />    <br />        return {<br />            getInstance: () => {<br />                if (!instance) instance = createInstance()<br />                return instance<br />        	}<br />        }<br />    })()<br />```<br /><br />#### Monostate...<br /><br />Respects the S.O.L.I.D principles.<br /><br />## Structural Design Patterns<br /><br />### Adapter<br /><br />Match interfaces of different classes, working as a wrapper. With an adapter, change the underline behaviour is not necessary.<br /><br />> *It's useful when you don't want your code to directly depend on third party code or legacy, uncoupling your code.*<br /><br />> **Changes the interface** but **doesn't change the implementation**.<br /><br />**Uses:**<br />- Frameworks<br />- External Libraries<br />- Legacy Codes<br /><br />**UML:**<br /><br />![adapter](https://user-images.githubusercontent.com/72560319/159727140-5ee62fd8-c556-47d4-b8e8-b2138c76c243.png)<br /><br />**In C#:**<br />```cs<br />public class Program<br />{<br />	public static void Main()<br />	{<br />		var target = new Adapter(new Adaptee());<br />		target.Request();<br />	}<br />}<br /><br />class Adaptee<br />{<br />	public void SpecificRequest()<br />	{<br />		// Logic<br />	}<br />}<br /><br />interface ITarget<br />{<br />	void Request();<br />} <br /><br />class Adapter : ITarget<br />{<br />	public Adapter(Adaptee a)<br />	{<br />		Adaptee = a;<br />	}<br />	<br />	public Adaptee Adaptee { get; set; }<br />	<br />	public void Request()<br />	{<br />		// Logic to adapt the method<br />		Adaptee.SpecficRequest();<br />	}<br />} <br />```<br /><br />**In TypeScript:**<br />```ts<br />> main.ts<br /><br />    import {<br />      EmailValidatorProtocol,<br />      EmailValidatorFnProtocol,<br />    } from './validation/email-validator-protocol'<br />    import { EmailValidatorClassAdapter } from './validation/email-validator-class-adapter'<br />    import { emailValidatorFnAdapter } from './validation/email-validator-fn-adapter'<br />    <br />    function validaEmailClass(<br />      emailValidator: EmailValidatorProtocol,<br />      email: string,<br />    ): void {<br />      if (emailValidator.isEmail(email)) {<br />        console.log('Email é válido (CLASS)')<br />      } else {<br />        console.log('Email é inválido (CLASS)')<br />      }<br />    }<br />    <br />    function validaEmailFn(<br />      emailValidator: EmailValidatorFnProtocol,<br />      email: string,<br />    ): void {<br />      if (emailValidator(email)) {<br />        console.log('Email é válido (FN)')<br />      } else {<br />        console.log('Email é inválido (FN)')<br />      }<br />    }<br />    <br />    const email = 'luizomf@gmail.com'<br />    validaEmailClass(new EmailValidatorClassAdapter(), email)<br />    validaEmailFn(emailValidatorFnAdapter, email)<br /><br />> email-validator-protocol.ts<br /><br />    export interface EmailValidatorProtocol {<br />      isEmail: EmailValidatorFnProtocol<br />    }<br />    <br />    export interface EmailValidatorFnProtocol {<br />      (value: string): boolean<br />    }<br /><br />> email-validator-class-adapter.ts<br /><br />    import isEmail from 'validator/lib/isEmail'<br />    import { EmailValidatorProtocol } from './email-validator-protocol'<br />    <br />    export class EmailValidatorClassAdapter implements EmailValidatorProtocol {<br />      isEmail(value: string): boolean {<br />        return isEmail(value)<br />      }<br />    }<br /><br />> email-validator-fn-adapter.ts<br /><br />    import isEmail from 'validator/lib/isEmail'<br />    import { EmailValidatorFnProtocol } from './email-validator-protocol'<br />    <br />    export const emailValidatorFnAdapter: EmailValidatorFnProtocol = (<br />      value: string,<br />    ): boolean => {<br />      return isEmail(value)<br />    }<br />```<br /><br />### Bridge<br /><br />Separates an object’s interface / abstraction from its implementation, so that the both can vary and evolve independently.<br /><br />> *Different from the adapter pattern, the bridge pattern is usually used before the project started, while the adapter is used after the project is already ongoing.*<br /><br />**Uses:**<br />- Frameworks<br />- External Libraries<br />- Legacy Codes<br /><br />**UML:**<br /><br />![bridge-pattern](https://user-images.githubusercontent.com/72560319/159353103-75e0b64a-b72e-46bf-bb00-c9fbd4f7a080.png)<br /><br />**In C#:**<br />```cs<br />abstract class View<br />{<br />	public View(IMediaResource mediaResource)<br />	{<br />		MediaResource = mediaResource;<br />	}<br />	<br />	public IMediaResource MediaResource;<br /><br />	public virtual string Show() { return "html"; }<br />}<br /><br />class ShortFormView : View<br />{<br />    public ShortFormView(IMediaResource mediaResource) : base(mediaResource)<br />    {<br />		MediaResource = mediaResource;<br />	}<br /><br />    public override string Show()<br />	{<br />		// Logic<br />		// MediaResource.Snippet;<br />		return "html";<br />	}<br />}<br /><br />class LongFormView : View<br />{<br />	public LongFormView(IMediaResource mediaResource) : base(mediaResource)<br />	{<br />		MediaResource = mediaResource;<br />	}<br /><br />	public override string Show()<br />	{<br />		// Logic<br />		// MediaResource.Snippet;<br />		return "html";<br />	}<br />}<br /><br />interface IMediaResource<br />{<br />	string Snippet { get; }<br />}<br /><br />class ArtistResource<br />{<br />	public ArtistResource(string bio)<br />    {<br />        Bio = bio;<br />    }<br />    <br />	public string Bio { get; set; }<br />}<br /><br />class ArtistAdapter : IMediaResource<br />{<br />	public ArtistAdapter(ArtistResource artistResource)<br />	{<br />		ArtistResource = artistResource;<br />	}<br />	<br />	public ArtistResource ArtistResource { get; set; }<br />	public string Snippet => ArtistResource.Bio;<br />}<br /><br />class BookResource<br />{<br />	public BookResource(string coverText)<br />    {<br />        CoverText = coverText;<br />    }<br />    <br />	public string CoverText { get; set; }<br />}<br /><br />class BookAdapter : IMediaResource<br />{<br />	public BookAdapter(BookResource bookResource)<br />	{<br />		BookResource = bookResource;<br />	}<br />	<br />	public BookResource BookResource { get; set; }<br />	public string Snippet => BookResource.CoverText;<br />}<br />```<br /><br />### Facade<br /><br />A single class (`wrapper`) that represents an entire subsystem in higher level. A facade helps to simply and unify a program.<br /><br />> High-level level abstraction over low-level components, where the **interface is changed** and the **implementation is not**.<br /><br />**Uses:**<br />- Operational Systems<br />- Compilers<br />- Complex Programs<br /><br />#### Law of Demeter (Principle of Least Knowledge)<br /><br />An object should never know the internal details of other objects.<br /><br />> By this, ```a().b().c()``` isn't correct, however ```a().b()``` is. <br /><br />**UML:**<br /><br />![facade](https://user-images.githubusercontent.com/72560319/159728186-1c2659b3-5f89-43d5-beec-2c67ca9b71c0.png)<br /><br />**In TypeScript:**<br />```ts<br />> customer-facade.ts<br /><br />    import { CustomerClient } from '../models/customer-client.ts'<br />    import { CustomerAvatar } from '../models/customer-avatar.ts'<br />    import { CustomerDocuments } from '../models/customer-documents.ts'<br />    import { CustomerAccessHistory } from '../models/customer-access-history.ts'<br />    import { CustomerService } from '../models/customer-service.ts'<br />    import { CustomerEmail } from '../models/customer-email.ts'<br />     <br />    export module Facade { <br />        export class CustomerFacade { <br />            static removeAccount(customer: Customer) {<br />                const customerAvatar = new CustomerAvatar(customer)<br />                const customerDocumentos = new CustomerDocuments(customer)<br />                const customerHistoricoAcesso = new CustomerAccessHistory(customer)<br />                const customerService = new CustomerService(customer)<br />                const customerEmail = new CustomerEmail(customer)<br />    <br />                customerAvatar.remove()<br />                customerDocumentos.delete()<br />                customerHistoricoAcesso.remove()<br />                customerService.delete()<br />                customerEmail.sendRemoveAccount()<br />            }<br />        }<br />    }<br /><br />> main.ts<br /><br />    import { CustomerClient } from '../models/customer-client.ts'<br />    import { Facade } from './facade/customer-facade.ts'<br />    <br />    const John = new Customer(<br />        "John Holts",<br />        "johnholts",<br />        "johnholts67@hotmail.com"<br />    )<br />    <br />    const Alice = new Customer(<br />        "Alice Cooper",<br />        "alicecooper",<br />        "alicecooperw@gmail.com"<br />    )<br />    <br />    Facade.CustomerFacade.removeAccount(John)<br />    Facade.CustomerFacade.removeAccount(Alice)<br />```<br /><br />### Proxy<br /><br />Provide a surrogate or placeholder for another object to control access to it, working as a middleware and adding a level of indirection.<br /><br />> *There is remote proxies (different context), virtual proxies (expensive crafting resources) and protection proxies (access management).*<br /><br />> **Changes the implementation** but **doesn't change the interface**.<br /><br />**Uses:**<br />- Networking<br />- VPNs<br />- Credit card validations<br />- Cache<br />- Logging<br /><br />**UML:**<br /><br />![proxy](https://user-images.githubusercontent.com/72560319/159519195-b962a1b8-2da4-48d3-88ff-8d464bd113a7.png)<br /><br />**In C#:**<br />```cs<br />interface IBookParser<br />{<br />    string Book { get; set; } <br />    int GetNumPages();<br />}<br /><br />class BookParser : IBookParser<br />{<br />    public BookParser(string book)<br />    {<br />        // Expensive parsing<br />        Book = book;<br />    }<br /><br />    public string Book { get; set; }<br /><br />    public int GetNumPages() => 0; // get the number of pages<br />}<br /><br />class LazyBookParserProxy : IBookParser<br />{<br />    public LazyBookParserProxy(string book)<br />    {<br />        BookParser = null;<br />        Book = book;<br />    }<br /><br />    private BookParser? BookParser;<br />    public string Book { get; set; }<br /><br />    public int GetNumPages()<br />    {<br />        if (BookParser == null)<br />            return 0;<br /><br />        BookParser = new BookParser(Book);<br />        return BookParser.GetNumPages();<br />    }<br />}<br />```<br /><br />**In TypeScript:**<br />```ts<br />    export interface Subject { <br />        request(): void<br />    } <br />    <br />    export class RealSubject implements Subject { <br />        request(): void { <br />            console.log('Something that the object do.')<br />        } <br />    } <br />    <br />    export class Proxy implements Subject { <br />        constructor(private subject: Subject) {} <br />    <br />        request(): void { <br />            console.log('The proxy do something')<br />            this.subject.request()<br />            console.log('The proxy can do other thing')<br />        } <br />    }<br />```<br /><br />### Decorator<br /><br />Add responsibilities and behaviours to objects dynamically at runtime wrapping them without the need to change them.<br /><br />> *The decorator pattern is useful to add features to existent code.*<br /><br />> **Changes the implementation** but **doesn't change the interface**.<br /><br />**Uses:**<br />- Cache<br />- Logging<br /><br />**UML:**<br /><br />![decorator](https://user-images.githubusercontent.com/72560319/159546636-9b279668-9f9d-40db-a87a-888dd913b008.png)<br /><br />**In C#:**<br />```cs<br />public class Program<br />{<br />    public static void Main()<br />    {<br />        var coffe = new CaramelDecorator(new ChocolateDecorator(new Expresso()));<br />    }<br />}<br /><br />interface IBeverage<br />{<br />    decimal Cost();<br />}<br /><br />class Decaf : IBeverage<br />{<br />    public decimal Cost() => 1.10m;<br />}<br /><br />class Expresso : IBeverage<br />{<br />    public decimal Cost() => 1.00m;<br />}<br /><br />interface IAdditionDecorator : IBeverage<br />{<br />    IBeverage Beverage { get; set; }<br />}<br /><br />class CaramelDecorator : IAdditionDecorator<br />{<br />    public CaramelDecorator(IBeverage beverage)<br />    {<br />        Beverage = beverage;<br />    }<br /><br />    public IBeverage Beverage { get; set; }<br /><br />    public decimal Cost() => Beverage.Cost() + 0.50m;<br />}<br /><br />class ChocolateDecorator : IAdditionDecorator<br />{<br />    public ChocolateDecorator(IBeverage beverage)<br />    {<br />        Beverage = beverage;<br />    }<br /><br />    public IBeverage Beverage { get; set; }<br /><br />    public decimal Cost() => Beverage.Cost() + 0.74m;<br />}<br />```<br /><br />**In TypeScript:**<br />```ts<br />> Class decorators<br /><br />    function log(constructor: any) {<br />        console.log(`New ${constructor.name} created!`)<br />    }<br />    <br />    @log<br />    class Yogurt {<br />        <br />        public flavor: string;<br />    <br />        constructor(flavor: string) {<br />            this.flavor = flavor<br />        }<br />    }<br /><br />> Method decorators<br /><br />    import userModel from './user.model'<br />    import UserNotFoundException from './UserNotFoundException'<br />    <br />    function excludeProperties(propertiesToExclude: string[]) {<br />        return (target: any, propertyName: string, descriptor: PropertyDescriptor) =&gt {<br />            const originalFunction = descriptor.value<br />            <br />            descriptor.value = async function(...args: any[]) {<br />                const originalResult = await originalFunction.apply(this, args)<br />                propertiesToExclude.forEach(propertyName =&gt {<br />                delete originalResult[propertyName]<br />                })<br />                return originalResult<br />            }<br />        }<br />    }<br />        <br />    class UserService {<br />        private user = userModel<br />        <br />        @excludeProperties(['password'])<br />        private getUser = async (userId: string) => {<br />            const user = await this.user.findById(userId)<br />            if (user) {<br />                return user<br />            }<br />            throw new UserNotFoundException(userId)<br />        }<br />    }<br />```<br /><br />### Composite<br /><br />A tree structure of composite objects and leaf objects.<br /><br />> *Composite pattern is useful with abstractions that can be hierarchically organized.*<br /><br />**Uses:**<br />- DOM<br />- TodoLists<br />- Genealogy<br /><br />**UML:**<br /><br />![composite-pattern](https://user-images.githubusercontent.com/72560319/159482200-4908a097-ae9d-4f25-8f8d-a4ffc76b1395.png)<br /><br />**In C#:**<br />```cs<br />interface ITodoList<br />{<br />	string getHtml();<br />}<br /><br />class Todo : ITodoList<br />{<br />    public Todo(string text)<br />    {<br />        Text = text;<br />    }<br />    <br />    public string Text { get; set; }<br /><br />    public string getHtml() <br />    { <br />        return "<li>" + Text + "</li>"; <br />    }<br />}<br /><br />class Project : ITodoList<br />{<br />    public Project(string title, List<ITodoList> todos)<br />    {<br />        Title = title;<br />        Todos = todos;<br />    }<br />    <br />    public string Title { get; set; }<br />    public List<ITodoList> Todos { get; set; }<br /><br />    public string getHtml() <br />    {<br />        var html = "<h1>" + Title + "</h1>";<br /><br />        html += "<ul>";<br />        Todos.ForEach(t => html += t.getHtml());<br />        html += "</ul>";<br /><br />        return html;<br />    }<br />}<br />```<br /><br />### Flyweight<br /><br />A fine-grained instance used for efficient sharing and memory saving, as if an flyweight object already exists, it will be returned and not created again.<br /><br />**Applicability:**<br />- High memory cost softwares<br />- Optimization<br />- Memory saving<br /><br />## Behavioral Patterns<br /><br />### Chain of Responsibility<br /><br />A way of passing a request between a chain of objects called handlers that pass the request forward until it is solved, similar to middlewares.<br /><br />> This pattern can be used when it's needed to execute several handlers in a particular order and handlers need to be created dynamically.<br /><br />> Chain of responsability pattern is useful to apply Single Responsability principle,  to structure your code with an business rule, to make it easy to add features and to alter these responsabilities without affecting the others.<br /><br />**Uses:**<br />- HTTP Requisitions<br />- Finances<br />- Validators<br />- Attendance Chain<br />- Rules Engine<br /><br />**UML:**<br /><br />![template-method](https://user-images.githubusercontent.com/72560319/159989992-f6133065-712b-4d65-9bb0-0114530f1c67.png)<br /><br />**In C#:**<br />```cs<br />// Client<br />class Attendance<br />{<br />    public void Treat(Call call)<br />    {<br />        var handler = new SalesHandler();<br />        handler<br />            .SetNextHandler(new RefoundHandler())<br />            .SetNextHandler(new MarketingHandler())<br />            .SetNextHandler(new OtherHandler());<br /><br />        handler.Handle(call);<br />    }<br />}<br /><br /><br />// Request<br />class Call<br />{<br />    public Call(uint option)<br />    {<br />        Option = option;<br />    }<br /><br />    public uint Option { get; set; }<br />    public bool Solved { get; set; }<br />}<br /><br />// Handlers<br />abstract class BaseHandler<br />{<br />    protected BaseHandler? _nextHandler { get; set; }<br /><br />    public BaseHandler SetNextHandler(BaseHandler nextHandler)<br />    {<br />        _nextHandler = nextHandler;<br />        return _nextHandler;<br />    }<br /><br />    public virtual Call Handle(Call call)<br />    {<br />        if (_nextHandler == null)<br />            return call;<br /><br />        return _nextHandler.Handle(call);<br />    }<br />}<br /><br />class SalesHandler : BaseHandler<br />{<br />    public override Call Handle(Call call)<br />    {<br />        if (call.Option == 1)<br />        {<br />            Console.WriteLine("Forwarding your call to Sales...");<br />            call.Solved = true;<br />            return call;<br />        }<br /><br />        return base.Handle(call);<br />    }<br />}<br /><br />class RefoundHandler : BaseHandler<br />{<br />    public override Call Handle(Call call)<br />    {<br />        if (call.Option == 2)<br />        {<br />            Console.WriteLine("Forwarding your call to Refound...");<br />            call.Solved = true;<br />            return call;<br />        }<br /><br />        return base.Handle(call);<br />    }<br />}<br /><br />class MarketingHandler : BaseHandler<br />{<br />    public override Call Handle(Call call)<br />    {<br />        if (call.Option == 3)<br />        {<br />            Console.WriteLine("Forwarding your call to Marketing...");<br />            call.Solved = true;<br />            return call;<br />        }<br /><br />        return base.Handle(call);<br />    }<br />}<br /><br />class OtherHandler : BaseHandler<br />{<br />    public override Call Handle(Call call)<br />    {<br />        Console.WriteLine("Forwarding your call to another sector...");<br />        call.Solved = true;<br />        return call;<br />    }<br />}<br />```<br /><br />### Command<br /><br />Encapsulates a command request as an object, supporting undoable operations.<br /><br />> With this pattern, instead of just perform some action, it's possible to wrap that action in a command and make sure it is undoable.<br /><br />**Uses:**<br />- Automation<br />- Request Queues<br />- Editors<br />- Do & Undo Operations<br />- Macro Commands<br /><br />**UML:**<br /><br />![command](https://user-images.githubusercontent.com/72560319/159564163-dc0e989b-49e8-4fda-9c7b-b0e0f7e3f1b9.png)<br /><br />**In C#:**<br />```cs<br />public class Program<br />{<br />    public static void Main()<br />    {<br />        var receiver = new Light();<br />        var invoker = new RemoteControl(<br />                        new LightOnCommand(receiver),<br />                        new LightOnCommand(receiver),<br />                        new LightOffCommand(receiver),<br />                        new LightOffCommand(receiver)<br />                      );<br />    }<br />}<br /><br />class RemoteControl // Invoker<br />{<br />    public RemoteControl(ICommand on, ICommand up, ICommand down, ICommand off)<br />    {<br />        On = on;<br />        Up = up;<br />        Down = down;<br />        Off = off;<br />    }<br /><br />    private ICommand On { get; set; }<br />    private ICommand Up { get; set; }<br />    private ICommand Down { get; set; }<br />    private ICommand Off { get; set; }<br /><br />    public void ClickOn() => On.Execute();<br />    public void ClickOff() => Off.Execute();<br />}<br /><br />interface ICommand<br />{<br />    void Execute();<br />    void Unexecute();<br />}<br /><br />class LightOnCommand : ICommand<br />{<br />    public LightOnCommand(Light light)<br />    {<br />        Light = light;<br />    }<br /><br />    public Light Light { get; set; }<br /><br />    public void Execute() => Light.On();<br />    public void Unexecute() => Light.Off();<br />}<br /><br />class LightOffCommand : ICommand<br />{<br />    public LightOffCommand(Light light)<br />    {<br />        Light = light;<br />    }<br /><br />    public Light Light { get; set; }<br /><br />    public void Execute() => Light.Off();<br />    public void Unexecute() => Light.On();<br />}<br /><br />class Light // Receiver<br />{<br />    public void On() { }<br />    public void Off() { }<br />}<br />```<br /><br />### Interpreter<br /><br />A way to include language elements in a program.<br /><br />### Iterator<br /><br />Sequentially access the elements of a collection, without exposing its underlying representation, that is, not exposing all the items right away.<br /><br />> Some benefits of iterator pattern is that is possible to create infinite collections and to pause the iteration to continue it later in a much easier way than `foreach`s with an index.<br /><br />**Uses:**<br />- Custom Collections<br />- Games<br /><br />**UML:**<br /><br />![iterator](https://user-images.githubusercontent.com/72560319/159944504-30077262-791e-433d-80c7-f25f24322081.png)<br /><br />**In C#:**<br />```cs<br />public class Program<br />{<br />    public static void Main()<br />    {<br />        var handHeldInventory = new HandHeldInventory(new FoodItem(1, "Apple", 20.00), new WeaponIem(2, "Sword", 60.00));<br />        var handItor = handHeldInventory.GetIterator();<br /><br />        while (!handItor.IsDone()) // Abstraction<br />        {<br />            Console.WriteLine(handItor.Current());<br />            handItor.Next();<br />        }        <br />        <br />        var backpackInventory = new BackpackInventory(new FoodItem(1, "Apple", 20.00), new FoodItem(1, "Bread", 40.00), new WeaponIem(2, "Sword", 60.00));<br />        var backpackItor = backpackInventory.GetIterator();<br /><br />        while (!backpackItor.IsDone()) // Same abstraction<br />        {<br />            Console.WriteLine(backpackItor.Current());<br />            backpackItor.Next();<br />        }<br />    }<br />}<br /><br />// Items<br />interface IItem<br />{<br />    uint Id { get; set; }<br />    string Name { get; set; }<br />}<br /><br />class FoodItem : IItem<br />{<br />    public FoodItem(uint id, string name, double regeneration)<br />    {<br />        Id = id;<br />        Name = name;<br />        Regeneration = regeneration;<br />    }<br /><br />    public uint Id { get; set; }<br />    public string Name { get; set; }<br />    public double Regeneration { get; set; }<br />}<br /><br />class WeaponIem : IItem<br />{<br />    public WeaponIem(uint id, string name, double damage)<br />    {<br />        Id = id;<br />        Name = name;<br />        Damage = damage;<br />    }<br /><br />    public uint Id { get; set; }<br />    public string Name { get; set; }<br />    public double Damage { get; set; }<br />}<br /><br />// Iterables<br />interface IInventory<br />{<br />    IInventoryIterator GetIterator();<br />}<br /><br />class HandHeldInventory : IInventory<br />{<br />    public HandHeldInventory(IItem leftItem, IItem rightItem)<br />    {<br />        LeftItem = leftItem;<br />        RightItem = rightItem;<br />    }<br /><br />    public IItem LeftItem { get; set; }<br />    public IItem RightItem { get; set; }<br /><br />    public IInventoryIterator GetIterator() => new HandHeldInventoryIterator(this); // Factory Method<br />}<br /><br />class BackpackInventory : IInventory<br />{<br />    public BackpackInventory(IItem item1, IItem item2, IItem item3)<br />    {<br />        Item1 = item1;<br />        Item2 = item2;<br />        Item3 = item3;<br />    }<br /><br />    public IItem Item1 { get; set; }<br />    public IItem Item2 { get; set; }<br />    public IItem Item3 { get; set; }<br />    // ...<br /><br />    public IInventoryIterator GetIterator() => new HandHeldInventoryIterator(this); // Factory Method<br />}<br /><br />// Iterators<br />interface IInventoryIterator<br />{<br />    bool IsDone();<br />    void Next();<br />    IItem? Current();<br />}<br /><br />class HandHeldInventoryIterator : IInventoryIterator<br />{<br />    public HandHeldInventoryIterator(HandHeldInventory inventory)<br />    {<br />        _inventory = inventory;<br />    }<br /><br />    private HandHeldInventory _inventory { get; set; } // Iterable<br />    private uint _index = 0;<br /><br />    public bool IsDone() => _index < 2;<br />    public void Next() => _index++;<br />    public IItem? Current()<br />    {<br />        switch (_index)<br />        {<br />            case 0:<br />                return _inventory.LeftItem;<br />            case 1:<br />                return _inventory.RightItem;<br />            default:<br />                return null;<br />        }<br />    }<br />}<br /><br />class BackpackInventoryIterator : IInventoryIterator<br />{<br />    public BackpackInventoryIterator(BackpackInventory inventory)<br />    {<br />        _inventory = inventory;<br />    }<br /><br />    private BackpackInventory _inventory { get; set; } // Iterable<br />    private uint _index = 0;<br /><br />    public bool IsDone() => _index < 3;<br />    public void Next() => _index++;<br />    public IItem? Current()<br />    {<br />        switch (_index)<br />        {<br />            case 0:<br />                return _inventory.Item1;<br />            case 1:<br />                return _inventory.Item2;<br />            case 2:<br />                return _inventory.Item3;<br />            default:<br />                return null;<br />        }<br />    }<br />}<br />```<br />#### Null Iterator<br /><br />> *For better undestanding, check the [Null Object Pattern](#null-object)*.<br /><br />Defines an always null iterator.<br /><br />**Uses:**<br />- Component Leaves (Composite Pattern)<br />- Null States (State Pattern)<br /><br />**In C#:**<br />```cs<br />class NullIterator : IIterator<br />{<br />    public NullIterator(IIterable iterable)<br />    {<br />        _iterable = iterable;<br />    }<br /><br />    private IIterable _iterable { get; set; }<br />    private uint _index = 0;<br /><br />    public bool IsDone() => true;<br />    public void Next() { }<br />    public IItem? Current() => null;<br />}<br />```<br /><br />### Mediator<br /><br />Defines simplified communication between classes.<br /><br />### Memento<br /><br />Capture and restore an object's internal state.<br /><br />### State<br /><br />Alter an object's behavior at runtime when its internal state changes.<br /><br />> The state is not an enum or property, it is an object. Therefore, it replaces a conditional with polymorphism.<br /><br />**Uses:**<br />- Network Requests<br />- UI Components<br />- No-Memory Machines<br /><br />![state-example](https://user-images.githubusercontent.com/72560319/159712767-c29a028c-22a5-4be6-9a2d-7390e533e2a8.png)<br /><br />**UML:**<br /><br />![state](https://user-images.githubusercontent.com/72560319/159712692-cf90884f-1bee-475d-94d7-e02a630e9bec.png)<br /><br />**In C#:**<br />```cs<br />class Gate<br />{<br />    public Gate(IGateState initialState)<br />    {<br />        State = initialState;<br />    }<br /><br />    public IGateState State { get; set; }<br /><br />    public void Enter() => State = State.Enter(); <br />    public void Pay() => State = State.Pay(); <br />    public void PayOk() => State = State.PayOk(); <br />    public void PayFailed() => State = State.PayFailed(); <br />}<br /><br />interface IGateState<br />{<br />    IGateState Enter();<br />    IGateState Pay();<br />    IGateState PayOk();<br />    IGateState PayFailed();<br />}<br /><br />class ClosedGateState : IGateState<br />{<br />    public IGateState Enter() => new ClosedGateState();<br />    public IGateState Pay() => new ProcessingPaymentGateState();<br />    public IGateState PayOk() => new ClosedGateState();<br />    public IGateState PayFailed() => new ClosedGateState();<br />}<br /><br />class ProcessingPaymentGateState : IGateState<br />{<br />    public IGateState Enter() => new ProcessingPaymentGateState();<br />    public IGateState Pay() => new ProcessingPaymentGateState();<br />    public IGateState PayOk() => new OpenGateState();<br />    public IGateState PayFailed() => new ClosedGateState();<br />}<br /><br />class OpenGateState : IGateState<br />{<br />    public IGateState Enter() => new ClosedGateState();<br />    public IGateState Pay() => new OpenGateState();<br />    public IGateState PayOk() => new OpenGateState();<br />    public IGateState PayFailed() => new OpenGateState();<br />}<br />```<br /><br />### Observer<br /><br />Defines an one to many dependency between objects, so that when the observable changes state all of its dependecies are notified and updated automatically.<br /><br />> *The observable is the object that changes and the observers are the objects interested in the observable changes.*<br /><br />**Uses:**<br />- Chats<br />- Sensors<br />- Newsletters<br />- Notifications<br /><br />**UML:**<br /><br />![observer](https://user-images.githubusercontent.com/72560319/159771101-5af99680-3192-430e-ac3e-ff87cc54c350.png)<br /><br />**In C#:**<br />```cs<br />public class Program<br />{<br />	public static void Main()<br />	{<br />		var station = new WeatherStation();<br />		station.Add(new PhoneDisplay(station));<br />		station.Add(new WindowDisplay(station));<br />	}<br />}<br /><br />interface IObservable<br />{<br />    List<IObserver> Observers { get; }<br /><br />    void Add(IObserver observer);<br />    void Remove(IObserver observer);<br />    void Notify();<br />}<br /><br />class WeatherStation : IObservable<br />{<br />    public WeatherStation()<br />    {<br />        Observers = new List<IObserver> { };<br />    }<br /><br />    public List<IObserver> Observers { get; private set; }<br /><br />    private decimal _temperature { get; set; }<br />    public decimal Temperature<br />    {<br />        get => _temperature;<br />        set <br />        { <br />            _temperature = value;<br />            Notify();<br />        }<br />    }<br /><br />    private decimal _humidity { get; set; }<br />    public decimal Humidity<br />    {<br />        get => _humidity;<br />        set<br />        {<br />            _humidity = value;<br />            Notify();<br />        }<br />    }<br /><br />    public void Add(IObserver observer) => Observers.Add(observer);<br />    public void Remove(IObserver observer) => Observers.Remove(observer);<br />    public void Notify() => Observers.ForEach(o => o.Update());<br />}<br /><br />interface IObserver<br />{<br />    void Update();<br />}<br /><br />class PhoneDisplay : IObserver<br />{<br />    public PhoneDisplay(WeatherStation station)<br />    {<br />        Station = station;<br />    }<br /><br />    public WeatherStation Station { get; init; }<br />    public decimal Temperature { get; private set; } // Only this state matters for this object<br /><br />    public void Update() <br />    {<br />        if (Temperature != Station.Temperature)<br />        {<br />            Temperature = Station.Temperature;<br />            Display();<br />        }<br />    }<br /><br />    public void Display() { } // Refreshes temperature on display<br />}<br /><br />class WindowDisplay : IObserver<br />{<br />    public WindowDisplay(WeatherStation station)<br />    {<br />        Station = station;<br />    }<br /><br />    public WeatherStation Station { get; init; }<br />    public decimal Humidity { get; private set; } // Only this state matters for this object<br /><br />    public void Update()<br />    {<br />        if (Humidity != Station.Humidity)<br />        {<br />            Humidity = Station.Humidity;<br />            Display();<br />        }<br />    }<br /><br />    public void Display() { } // Refreshes humidity on display<br />}<br />```<br /><br />### Strategy<br /><br />Encapsulates an algorithm inside a class and allows that a class behavior or its algorithm can be changed at runtime.<br /><br />> *The strategy pattern is about using composition and dependency injection instead of inheritance.*<br /><br />> *This pattern is useful to encapsulate business rules, once it can remove the need of subclasses and transform abstract classes into normal classes.*<br /><br />**Uses:**<br />- Ecommerces<br />- Finances<br />- Law<br /><br />**UML:**<br /><br />![strategy](https://user-images.githubusercontent.com/72560319/159779934-01d3c83e-a469-4b82-812f-d52cb7e443fb.png)<br /><br />**In C#:**<br />```cs<br />public class Program<br />{<br />    public static void Main()<br />    {<br />        var cityDuck = new Duck(new SimpleQuacking(), new SimpleFlying(), new DisplayAsText());<br />        var wildDuck = new Duck(new SimpleQuacking(), new JetFlying(), new DisplayAsGraphics());<br />        var mountainDuck = new Duck(new SimpleQuacking(), new JetFlying(), new DisplayAsText());<br />        var rubberDuck = new Duck(new NoQuacking(), new SimpleFlying(), new DisplayAsGraphics());<br />    }<br />}<br /><br />class Duck<br />{<br />    public Duck(IQuackBehaviour quackBehaviour, IFlyBehaviour flyBehaviour, IDisplayBehaviour displayBehaviour)<br />    {<br />        QuackBehaviour = quackBehaviour;<br />        FlyBehaviour = flyBehaviour;<br />        DisplayBehaviour = displayBehaviour;<br />    }<br /><br />    public IQuackBehaviour QuackBehaviour { get; set; }<br />    public IFlyBehaviour FlyBehaviour { get; set; }<br />    public IDisplayBehaviour DisplayBehaviour { get; set; }<br /><br />    public void Quack() => QuackBehaviour.Quack();<br />    public void Fly() => FlyBehaviour.Fly();<br />    public void Display() => DisplayBehaviour.Display();<br />}<br /><br />interface IQuackBehaviour<br />{<br />    void Quack();<br />}<br /><br />class SimpleQuacking : IQuackBehaviour<br />{<br />    public void Quack()<br />    {<br />        // Logic<br />    }<br />}<br /><br />class NoQuacking : IQuackBehaviour<br />{<br />    public void Quack()<br />    {<br />        // Logic<br />    }<br />}<br /><br />interface IFlyBehaviour<br />{<br />    void Fly();<br />}<br /><br />class SimpleFlying : IFlyBehaviour<br />{<br />    public void Fly()<br />    {<br />        // Logic<br />    }<br />}<br /><br />class JetFlying : IFlyBehaviour<br />{<br />    public void Fly()<br />    {<br />        // Logic<br />    }<br />}<br /><br />interface IDisplayBehaviour<br />{<br />    void Display();<br />}<br /><br />class DisplayAsText : IDisplayBehaviour<br />{<br />    public void Display()<br />    {<br />        // Logic<br />    }<br />}<br /><br />class DisplayAsGraphics : IDisplayBehaviour<br />{<br />    public void Display()<br />    {<br />        // Logic<br />    }<br />}<br />```<br /><br />### Template Method<br /><br />Defer the exact steps of an algorithm to a subclass, working as a blueprint for methods.<br /><br />> *Template method pattern works better in cases where strategy doesn't fit and there is fixed logic on the template. Anyway, it can be very dangerous given that it uses inheritance over composition.*<br /><br />> *A template method class is composed by a defined method (template method) and the empty methods (hooks) that are called inside the template method.*<br /><br />> *This pattern is similitar to inversion of dependency pattern, like the Hollywood principle: "Don't call us, we'll call you. Or not."* <br /><br />**Uses:**<br />- Frameworks<br />- Database Operations<br /><br />**UML:**<br /><br />![template-method](https://user-images.githubusercontent.com/72560319/159915346-6633ca6f-0198-43cb-b041-3090c50ebe83.png)<br /><br />**In C#:**<br />```cs<br />abstract class Record<br />{<br />    public void Save()<br />    {<br />        Validate();<br />        BeforeSave();<br />        // Save to DB<br />        AfterSave();<br />    }<br /><br />    // Hooks<br />    public virtual void Validate() { }<br />    public virtual void BeforeSave() { }<br />    public virtual void AfterSave() { }<br />}<br /><br />class UserRecord : Record<br />{<br />    public override void Validate()<br />    {<br />        // Logic<br />    }<br /><br />    public override void BeforeSave()<br />    {<br />        // Logic<br />    }<br />}<br /><br />class PostRecord : Record<br />{<br />    public override void Validate()<br />    {<br />        // Logic<br />    }<br /><br />    public override void AfterSave()<br />    {<br />        // Logic<br />    }<br />}<br />```<br /><br />### Visitor<br /><br />Defines a new operation to a class without change.<br /><br />## Other Patterns<br /><br />### Null Object<br /><br />Designed to act as a default value of an object, working as a null state.<br /><br />> *This pattern make it possible to handle nullness in the same way that somethingness is handled.*<br /><br />### Honorable Mentions<br /><br />-   **Dependency Injection**<br />-   **Inversion of Control**<br />-   **Inversion of Dependency**<br />-   **Lazy Loading**<br />-   **Object Pool:** avoid expensive acquisition and release of resources by recycling objects that are no longer in use<br />- **Private Class Data:** restricts accessor/mutator access.<br />-   **Mock Object**<br />-   **Rules Design Patterns**<br />-   **Intercepting Filter**<br />-   **Method Chaining**<br />-   **Unit of Work**<br /><br />|# Design Patterns<br /><br />- [Design Patterns](#design-patterns)<br />  * [Creational Design Patterns](#creational-design-patterns)<br />    + [Factory Method](#factory-method)<br />    + [Abstract Factory](#abstract-factory)<br />    + [Builder](#builder)<br />    + [Prototype](#prototype)<br />    + [Singleton](#singleton)<br />      - [Monostate...](#monostate)<br />  * [Structural Design Patterns](#structural-design-patterns)<br />    + [Adapter](#adapter)<br />    + [Bridge](#bridge)<br />    + [Facade](#facade)<br />      - [Law of Demeter (Principle of Least Knowledge)](#law-of-demeter--principle-of-least-knowledge-)<br />    + [Proxy](#proxy)<br />    + [Decorator](#decorator)<br />    + [Composite](#composite)<br />    + [Flyweight](#flyweight)<br />  * [Behavioral Patterns](#behavioral-patterns)<br />    + [Chain of Responsibility](#chain-of-responsibility)<br />    + [Command](#command)<br />    + [Interpreter](#interpreter)<br />    + [Iterator](#iterator)<br />      - [Null Iterator](#null-iterator)<br />    + [Mediator](#mediator)<br />    + [Memento](#memento)<br />    + [State](#state)<br />    + [Observer](#observer)<br />    + [Strategy](#strategy)<br />    + [Template Method](#template-method)<br />    + [Visitor](#visitor)<br />  * [Other Patterns](#other-patterns)<br />    + [Null Object](#null-object)<br />    + [Honorable Mentions](#honorable-mentions)<br /><br /><small><i><a href='http://ecotrust-canada.github.io/markdown-toc/'>Table of contents generated with markdown-toc</a></i></small><br /><br /><br />## Creational Design Patterns<br /><br />###  Factory Method<br /><br />Creates an instance of several derived classes.<br /><br />> *Abstract the instantiation of objects by wrapping them in a Factory method.*<br /><br />**Uses:**<br />- Frameworks<br />- TDD<br /><br />**UML:**<br /><br />![factory-method](https://user-images.githubusercontent.com/72560319/159106269-6a0b440f-ad84-4f1b-bc60-9252db988268.png)<br /><br />**In C#:**<br />```cs<br />public class Program<br />{<br />	public static void Main()<br />	{<br />		var animal1 = new BalancedAnimalFactory().CreateAnimal();<br />		var animal2 = new RandomAnimalFactory().CreateAnimal();<br />	}<br />}<br />	<br />public abstract class Animal { }<br /><br />public class Dog : Animal { }<br />public class Cat : Animal { }<br />public class Duck : Animal { }<br /><br />public interface IAnimalFactory <br />{<br />	public Animal CreateAnimal();<br />}<br /><br />public class BalancedAnimalFactory : IAnimalFactory<br />{<br />	public Animal CreateAnimal()<br />	{<br />		// Logic<br />		return new Dog();<br />	}<br />}<br /><br />public class RandomAnimalFactory : IAnimalFactory<br />{<br />	public Animal CreateAnimal()<br />	{<br />		// Logic<br />		return new Cat();<br />	}<br />}<br />```<br /><br />**In TypeScript:**<br />```ts<br />    function fabricatePerson(name, lastname) {<br />        let person = {}<br />        person.name = name<br />        person.lastname = lastname<br />            <br />        function fullName() {<br />    	    return `${person.name} ${person.lastname}`<br />        }<br /><br />		person.fullName<br />        <br />        return person<br />    }<br />```<br /><br />###  Abstract Factory<br /><br />Create an object without exposing the creation logic to the client and refer to newly created object using a common interface.<br /><br />**Uses:**<br />- UI Controls<br />- Multiplatform Toolkits<br />- Product Families<br /><br />**UML:** <br /><br />![abstract-factory](https://user-images.githubusercontent.com/72560319/159106388-4cc123cf-d58e-4857-8d55-921cf0a3bd78.png)<br /><br />**In C#:**<br />```cs<br />public class Program<br />{<br />	public static void Main()<br />	{<br />		new NavigationBar(new Android());<br />		new DropdownMenu(new Android());<br />	}<br />}<br /><br />public class Button<br />{<br />	public string Type { get; set; }<br />}<br /><br />public interface IUIFactory<br />{<br />	public Button CreateButton();<br />}<br /><br />public class Apple : IUIFactory<br />{<br />	public Button CreateButton()<br />	{<br />		return new Button { Type = "iOS Button".Dump() };<br />	}<br />}<br /><br />public class Android : IUIFactory<br />{<br />	public Button CreateButton()<br />	{<br />		return new Button { Type = "Android Button".Dump() };<br />	}<br />}<br /><br />public class NavigationBar<br />{<br />	public NavigationBar(IUIFactory factory) => factory.CreateButton();<br />}<br /><br />public class DropdownMenu<br />{<br />	public DropdownMenu(IUIFactory factory) => factory.CreateButton();<br />}<br />```<br /><br />**In TypeScript:**<br />```ts<br />    abstract class Animal {}<br />    <br />    abstract class Bird extends Animal {}<br />    <br />    abstract class Reptile extends Animal {}<br />    <br />    class Hawk extends Bird {}<br />    <br />    class Alligator extends Reptile {}<br />```<br /><br />###  Builder<br /><br />Separates object construction from its representation. <br /><br />A `Builder` abstract class or interface and one `ConcreteBuilder` for each variation of the product.<br /><br />**Uses:**<br />- Templates<br />- Text Editors<br /><br />**In TypeScript:**<br />```ts<br />    var Task = (name, description, finished, dueDate) => {<br />        this.name = name<br />        this.description = description<br />        this.finished = finished<br />        this.dueDate = dueDate<br />    }<br />    <br />    var TaskBuilder = () => {    <br />        let name<br />        let description<br />        let isFinished = false<br />        let dueDate<br />    <br />        return {<br />            setName: name => {<br />                this.name = name<br />                return this<br />            },<br />            setDescription: description => {<br />                this.description = description<br />                return this<br />            },<br />            setFinished: finished => {<br />                this.finished = finished<br />                return this<br />            },<br />            setDueDate: dueDate => {<br />                this.dueDate = dueDate<br />                return this<br />            },<br />            build: () => {<br />                return new Task(name, description, isFinished, dueDate)<br />            }<br />        }<br />    }<br />    <br />    let task = new TaskBuilder().setName('Task A').setDescription('finish book')<br />        .setDueDate(new Date(2019, 5, 12))<br />```<br />    <br />###  Prototype<br /><br />A fully initialized instance to be copied or cloned and then modified.<br /><br />**Uses:**<br />- Avoid unnecessary subclasses<br />- JavaScript and TypeScript<br /><br />**In TypeScript:**<br />```ts<br />    interface Prototype {<br />        clone(): Prototype<br />    }<br />    <br />    class Person implements Prototype {<br />        constructor(public name: string, public age: number) {}<br />    	<br />        clone(): this {<br />            const newPerson = Object.create(this)<br />            return newPerson<br />        }<br />    }<br />    <br />    const person1 = new Person('Luiz', 30)<br />    const person2 = person1.clone()<br />```<br /><br />###  Singleton<br /><br />A class of which only a single instance can exist and that provides a global access to itl. <br /><br />All singletons have a private constructor (`createInstance`), a public access method (`getInstance`) and a static attribute (`instance`).<br /><br />> If possible, avoid singletons at all. They can be very tricky to escalate and to work with TDD, as one man's constant is one man's variable.<br /><br />> In a way, it's completely fine to have a single object within an application, but it isn't to make it impossible to create a second instance.<br /><br />**Uses:**<br />- Database Configuration<br /><br />**UML:**<br /><br />![singleton](https://user-images.githubusercontent.com/72560319/159556077-69285a0d-d32d-4b24-ad8f-b8a8a1f301b8.png)<br /><br />**In C#:**<br />```cs<br />class Singleton<br />{<br />    private Singleton() { }<br /><br />    private static Singleton? Instance;<br /><br />    public static void GetInstance()<br />    {<br />        if (Instance == null)<br />            Instance = new Singleton();<br />    }<br />}<br />```<br /><br />**In TypeScript:**<br />```ts<br />    const database = (() => {<br />        var instance<br />    <br />        function createInstance() {<br />            var object = new Object("I am the instance")<br />            return object<br />        }<br />    <br />        return {<br />            getInstance: () => {<br />                if (!instance) instance = createInstance()<br />                return instance<br />        	}<br />        }<br />    })()<br />```<br /><br />#### Monostate...<br /><br />Respects the S.O.L.I.D principles.<br /><br />## Structural Design Patterns<br /><br />### Adapter<br /><br />Match interfaces of different classes, working as a wrapper. With an adapter, change the underline behaviour is not necessary.<br /><br />> *It's useful when you don't want your code to directly depend on third party code or legacy, uncoupling your code.*<br /><br />> **Changes the interface** but **doesn't change the implementation**.<br /><br />**Uses:**<br />- Frameworks<br />- External Libraries<br />- Legacy Codes<br /><br />**UML:**<br /><br />![adapter](https://user-images.githubusercontent.com/72560319/159727140-5ee62fd8-c556-47d4-b8e8-b2138c76c243.png)<br /><br />**In C#:**<br />```cs<br />public class Program<br />{<br />	public static void Main()<br />	{<br />		var target = new Adapter(new Adaptee());<br />		target.Request();<br />	}<br />}<br /><br />class Adaptee<br />{<br />	public void SpecificRequest()<br />	{<br />		// Logic<br />	}<br />}<br /><br />interface ITarget<br />{<br />	void Request();<br />} <br /><br />class Adapter : ITarget<br />{<br />	public Adapter(Adaptee a)<br />	{<br />		Adaptee = a;<br />	}<br />	<br />	public Adaptee Adaptee { get; set; }<br />	<br />	public void Request()<br />	{<br />		// Logic to adapt the method<br />		Adaptee.SpecficRequest();<br />	}<br />} <br />```<br /><br />**In TypeScript:**<br />```ts<br />> main.ts<br /><br />    import {<br />      EmailValidatorProtocol,<br />      EmailValidatorFnProtocol,<br />    } from './validation/email-validator-protocol'<br />    import { EmailValidatorClassAdapter } from './validation/email-validator-class-adapter'<br />    import { emailValidatorFnAdapter } from './validation/email-validator-fn-adapter'<br />    <br />    function validaEmailClass(<br />      emailValidator: EmailValidatorProtocol,<br />      email: string,<br />    ): void {<br />      if (emailValidator.isEmail(email)) {<br />        console.log('Email é válido (CLASS)')<br />      } else {<br />        console.log('Email é inválido (CLASS)')<br />      }<br />    }<br />    <br />    function validaEmailFn(<br />      emailValidator: EmailValidatorFnProtocol,<br />      email: string,<br />    ): void {<br />      if (emailValidator(email)) {<br />        console.log('Email é válido (FN)')<br />      } else {<br />        console.log('Email é inválido (FN)')<br />      }<br />    }<br />    <br />    const email = 'luizomf@gmail.com'<br />    validaEmailClass(new EmailValidatorClassAdapter(), email)<br />    validaEmailFn(emailValidatorFnAdapter, email)<br /><br />> email-validator-protocol.ts<br /><br />    export interface EmailValidatorProtocol {<br />      isEmail: EmailValidatorFnProtocol<br />    }<br />    <br />    export interface EmailValidatorFnProtocol {<br />      (value: string): boolean<br />    }<br /><br />> email-validator-class-adapter.ts<br /><br />    import isEmail from 'validator/lib/isEmail'<br />    import { EmailValidatorProtocol } from './email-validator-protocol'<br />    <br />    export class EmailValidatorClassAdapter implements EmailValidatorProtocol {<br />      isEmail(value: string): boolean {<br />        return isEmail(value)<br />      }<br />    }<br /><br />> email-validator-fn-adapter.ts<br /><br />    import isEmail from 'validator/lib/isEmail'<br />    import { EmailValidatorFnProtocol } from './email-validator-protocol'<br />    <br />    export const emailValidatorFnAdapter: EmailValidatorFnProtocol = (<br />      value: string,<br />    ): boolean => {<br />      return isEmail(value)<br />    }<br />```<br /><br />### Bridge<br /><br />Separates an object’s interface / abstraction from its implementation, so that the both can vary and evolve independently.<br /><br />> *Different from the adapter pattern, the bridge pattern is usually used before the project started, while the adapter is used after the project is already ongoing.*<br /><br />**Uses:**<br />- Frameworks<br />- External Libraries<br />- Legacy Codes<br /><br />**UML:**<br /><br />![bridge-pattern](https://user-images.githubusercontent.com/72560319/159353103-75e0b64a-b72e-46bf-bb00-c9fbd4f7a080.png)<br /><br />**In C#:**<br />```cs<br />abstract class View<br />{<br />	public View(IMediaResource mediaResource)<br />	{<br />		MediaResource = mediaResource;<br />	}<br />	<br />	public IMediaResource MediaResource;<br /><br />	public virtual string Show() { return "html"; }<br />}<br /><br />class ShortFormView : View<br />{<br />    public ShortFormView(IMediaResource mediaResource) : base(mediaResource)<br />    {<br />		MediaResource = mediaResource;<br />	}<br /><br />    public override string Show()<br />	{<br />		// Logic<br />		// MediaResource.Snippet;<br />		return "html";<br />	}<br />}<br /><br />class LongFormView : View<br />{<br />	public LongFormView(IMediaResource mediaResource) : base(mediaResource)<br />	{<br />		MediaResource = mediaResource;<br />	}<br /><br />	public override string Show()<br />	{<br />		// Logic<br />		// MediaResource.Snippet;<br />		return "html";<br />	}<br />}<br /><br />interface IMediaResource<br />{<br />	string Snippet { get; }<br />}<br /><br />class ArtistResource<br />{<br />	public ArtistResource(string bio)<br />    {<br />        Bio = bio;<br />    }<br />    <br />	public string Bio { get; set; }<br />}<br /><br />class ArtistAdapter : IMediaResource<br />{<br />	public ArtistAdapter(ArtistResource artistResource)<br />	{<br />		ArtistResource = artistResource;<br />	}<br />	<br />	public ArtistResource ArtistResource { get; set; }<br />	public string Snippet => ArtistResource.Bio;<br />}<br /><br />class BookResource<br />{<br />	public BookResource(string coverText)<br />    {<br />        CoverText = coverText;<br />    }<br />    <br />	public string CoverText { get; set; }<br />}<br /><br />class BookAdapter : IMediaResource<br />{<br />	public BookAdapter(BookResource bookResource)<br />	{<br />		BookResource = bookResource;<br />	}<br />	<br />	public BookResource BookResource { get; set; }<br />	public string Snippet => BookResource.CoverText;<br />}<br />```<br /><br />### Facade<br /><br />A single class (`wrapper`) that represents an entire subsystem in higher level. A facade helps to simply and unify a program.<br /><br />> High-level level abstraction over low-level components, where the **interface is changed** and the **implementation is not**.<br /><br />**Uses:**<br />- Operational Systems<br />- Compilers<br />- Complex Programs<br /><br />#### Law of Demeter (Principle of Least Knowledge)<br /><br />An object should never know the internal details of other objects.<br /><br />> By this, ```a().b().c()``` isn't correct, however ```a().b()``` is. <br /><br />**UML:**<br /><br />![facade](https://user-images.githubusercontent.com/72560319/159728186-1c2659b3-5f89-43d5-beec-2c67ca9b71c0.png)<br /><br />**In TypeScript:**<br />```ts<br />> customer-facade.ts<br /><br />    import { CustomerClient } from '../models/customer-client.ts'<br />    import { CustomerAvatar } from '../models/customer-avatar.ts'<br />    import { CustomerDocuments } from '../models/customer-documents.ts'<br />    import { CustomerAccessHistory } from '../models/customer-access-history.ts'<br />    import { CustomerService } from '../models/customer-service.ts'<br />    import { CustomerEmail } from '../models/customer-email.ts'<br />     <br />    export module Facade { <br />        export class CustomerFacade { <br />            static removeAccount(customer: Customer) {<br />                const customerAvatar = new CustomerAvatar(customer)<br />                const customerDocumentos = new CustomerDocuments(customer)<br />                const customerHistoricoAcesso = new CustomerAccessHistory(customer)<br />                const customerService = new CustomerService(customer)<br />                const customerEmail = new CustomerEmail(customer)<br />    <br />                customerAvatar.remove()<br />                customerDocumentos.delete()<br />                customerHistoricoAcesso.remove()<br />                customerService.delete()<br />                customerEmail.sendRemoveAccount()<br />            }<br />        }<br />    }<br /><br />> main.ts<br /><br />    import { CustomerClient } from '../models/customer-client.ts'<br />    import { Facade } from './facade/customer-facade.ts'<br />    <br />    const John = new Customer(<br />        "John Holts",<br />        "johnholts",<br />        "johnholts67@hotmail.com"<br />    )<br />    <br />    const Alice = new Customer(<br />        "Alice Cooper",<br />        "alicecooper",<br />        "alicecooperw@gmail.com"<br />    )<br />    <br />    Facade.CustomerFacade.removeAccount(John)<br />    Facade.CustomerFacade.removeAccount(Alice)<br />```<br /><br />### Proxy<br /><br />Provide a surrogate or placeholder for another object to control access to it, working as a middleware and adding a level of indirection.<br /><br />> *There is remote proxies (different context), virtual proxies (expensive crafting resources) and protection proxies (access management).*<br /><br />> **Changes the implementation** but **doesn't change the interface**.<br /><br />**Uses:**<br />- Networking<br />- VPNs<br />- Credit card validations<br />- Cache<br />- Logging<br /><br />**UML:**<br /><br />![proxy](https://user-images.githubusercontent.com/72560319/159519195-b962a1b8-2da4-48d3-88ff-8d464bd113a7.png)<br /><br />**In C#:**<br />```cs<br />interface IBookParser<br />{<br />    string Book { get; set; } <br />    int GetNumPages();<br />}<br /><br />class BookParser : IBookParser<br />{<br />    public BookParser(string book)<br />    {<br />        // Expensive parsing<br />        Book = book;<br />    }<br /><br />    public string Book { get; set; }<br /><br />    public int GetNumPages() => 0; // get the number of pages<br />}<br /><br />class LazyBookParserProxy : IBookParser<br />{<br />    public LazyBookParserProxy(string book)<br />    {<br />        BookParser = null;<br />        Book = book;<br />    }<br /><br />    private BookParser? BookParser;<br />    public string Book { get; set; }<br /><br />    public int GetNumPages()<br />    {<br />        if (BookParser == null)<br />            return 0;<br /><br />        BookParser = new BookParser(Book);<br />        return BookParser.GetNumPages();<br />    }<br />}<br />```<br /><br />**In TypeScript:**<br />```ts<br />    export interface Subject { <br />        request(): void<br />    } <br />    <br />    export class RealSubject implements Subject { <br />        request(): void { <br />            console.log('Something that the object do.')<br />        } <br />    } <br />    <br />    export class Proxy implements Subject { <br />        constructor(private subject: Subject) {} <br />    <br />        request(): void { <br />            console.log('The proxy do something')<br />            this.subject.request()<br />            console.log('The proxy can do other thing')<br />        } <br />    }<br />```<br /><br />### Decorator<br /><br />Add responsibilities and behaviours to objects dynamically at runtime wrapping them without the need to change them.<br /><br />> *The decorator pattern is useful to add features to existent code.*<br /><br />> **Changes the implementation** but **doesn't change the interface**.<br /><br />**Uses:**<br />- Cache<br />- Logging<br /><br />**UML:**<br /><br />![decorator](https://user-images.githubusercontent.com/72560319/159546636-9b279668-9f9d-40db-a87a-888dd913b008.png)<br /><br />**In C#:**<br />```cs<br />public class Program<br />{<br />    public static void Main()<br />    {<br />        var coffe = new CaramelDecorator(new ChocolateDecorator(new Expresso()));<br />    }<br />}<br /><br />interface IBeverage<br />{<br />    decimal Cost();<br />}<br /><br />class Decaf : IBeverage<br />{<br />    public decimal Cost() => 1.10m;<br />}<br /><br />class Expresso : IBeverage<br />{<br />    public decimal Cost() => 1.00m;<br />}<br /><br />interface IAdditionDecorator : IBeverage<br />{<br />    IBeverage Beverage { get; set; }<br />}<br /><br />class CaramelDecorator : IAdditionDecorator<br />{<br />    public CaramelDecorator(IBeverage beverage)<br />    {<br />        Beverage = beverage;<br />    }<br /><br />    public IBeverage Beverage { get; set; }<br /><br />    public decimal Cost() => Beverage.Cost() + 0.50m;<br />}<br /><br />class ChocolateDecorator : IAdditionDecorator<br />{<br />    public ChocolateDecorator(IBeverage beverage)<br />    {<br />        Beverage = beverage;<br />    }<br /><br />    public IBeverage Beverage { get; set; }<br /><br />    public decimal Cost() => Beverage.Cost() + 0.74m;<br />}<br />```<br /><br />**In TypeScript:**<br />```ts<br />> Class decorators<br /><br />    function log(constructor: any) {<br />        console.log(`New ${constructor.name} created!`)<br />    }<br />    <br />    @log<br />    class Yogurt {<br />        <br />        public flavor: string;<br />    <br />        constructor(flavor: string) {<br />            this.flavor = flavor<br />        }<br />    }<br /><br />> Method decorators<br /><br />    import userModel from './user.model'<br />    import UserNotFoundException from './UserNotFoundException'<br />    <br />    function excludeProperties(propertiesToExclude: string[]) {<br />        return (target: any, propertyName: string, descriptor: PropertyDescriptor) =&gt {<br />            const originalFunction = descriptor.value<br />            <br />            descriptor.value = async function(...args: any[]) {<br />                const originalResult = await originalFunction.apply(this, args)<br />                propertiesToExclude.forEach(propertyName =&gt {<br />                delete originalResult[propertyName]<br />                })<br />                return originalResult<br />            }<br />        }<br />    }<br />        <br />    class UserService {<br />        private user = userModel<br />        <br />        @excludeProperties(['password'])<br />        private getUser = async (userId: string) => {<br />            const user = await this.user.findById(userId)<br />            if (user) {<br />                return user<br />            }<br />            throw new UserNotFoundException(userId)<br />        }<br />    }<br />```<br /><br />### Composite<br /><br />A tree structure of composite objects and leaf objects.<br /><br />> *Composite pattern is useful with abstractions that can be hierarchically organized.*<br /><br />**Uses:**<br />- DOM<br />- TodoLists<br />- Genealogy<br /><br />**UML:**<br /><br />![composite-pattern](https://user-images.githubusercontent.com/72560319/159482200-4908a097-ae9d-4f25-8f8d-a4ffc76b1395.png)<br /><br />**In C#:**<br />```cs<br />interface ITodoList<br />{<br />	string getHtml();<br />}<br /><br />class Todo : ITodoList<br />{<br />    public Todo(string text)<br />    {<br />        Text = text;<br />    }<br />    <br />    public string Text { get; set; }<br /><br />    public string getHtml() <br />    { <br />        return "<li>" + Text + "</li>"; <br />    }<br />}<br /><br />class Project : ITodoList<br />{<br />    public Project(string title, List<ITodoList> todos)<br />    {<br />        Title = title;<br />        Todos = todos;<br />    }<br />    <br />    public string Title { get; set; }<br />    public List<ITodoList> Todos { get; set; }<br /><br />    public string getHtml() <br />    {<br />        var html = "<h1>" + Title + "</h1>";<br /><br />        html += "<ul>";<br />        Todos.ForEach(t => html += t.getHtml());<br />        html += "</ul>";<br /><br />        return html;<br />    }<br />}<br />```<br /><br />### Flyweight<br /><br />A fine-grained instance used for efficient sharing and memory saving, as if an flyweight object already exists, it will be returned and not created again.<br /><br />**Applicability:**<br />- High memory cost softwares<br />- Optimization<br />- Memory saving<br /><br />## Behavioral Patterns<br /><br />### Chain of Responsibility<br /><br />A way of passing a request between a chain of objects called handlers that pass the request forward until it is solved, similar to middlewares.<br /><br />> This pattern can be used when it's needed to execute several handlers in a particular order and handlers need to be specified dynamically.<br /><br />> Chain of responsability pattern is useful to apply Single Responsability principle,  to structure your code with an business rule, to make it easy to add features and to alter these responsabilities without affecting the others.<br /><br />**Uses:**<br />- HTTP Requisitions<br />- Finances<br />- Validators<br />- Attendance Chain<br />- Rules Engine<br /><br />**UML:**<br /><br />![chain-of-responsability](https://user-images.githubusercontent.com/72560319/159990391-5a84726d-1cde-4838-a199-1db692df49ed.png)<br /><br />**In C#:**<br />```cs<br />// Client<br />class Attendance<br />{<br />    public void Treat(Call call)<br />    {<br />        var handler = new SalesHandler();<br />        handler<br />            .SetNextHandler(new RefoundHandler())<br />            .SetNextHandler(new MarketingHandler())<br />            .SetNextHandler(new OtherHandler());<br /><br />        handler.Handle(call);<br />    }<br />}<br /><br /><br />// Request<br />class Call<br />{<br />    public Call(uint option)<br />    {<br />        Option = option;<br />    }<br /><br />    public uint Option { get; set; }<br />    public bool Solved { get; set; }<br />}<br /><br />// Handlers<br />abstract class BaseHandler<br />{<br />    protected BaseHandler? _nextHandler { get; set; }<br /><br />    public BaseHandler SetNextHandler(BaseHandler nextHandler)<br />    {<br />        _nextHandler = nextHandler;<br />        return _nextHandler;<br />    }<br /><br />    public virtual Call Handle(Call call)<br />    {<br />        if (_nextHandler == null)<br />            return call;<br /><br />        return _nextHandler.Handle(call);<br />    }<br />}<br /><br />class SalesHandler : BaseHandler<br />{<br />    public override Call Handle(Call call)<br />    {<br />        if (call.Option == 1)<br />        {<br />            Console.WriteLine("Forwarding your call to Sales...");<br />            call.Solved = true;<br />            return call;<br />        }<br /><br />        return base.Handle(call);<br />    }<br />}<br /><br />class RefoundHandler : BaseHandler<br />{<br />    public override Call Handle(Call call)<br />    {<br />        if (call.Option == 2)<br />        {<br />            Console.WriteLine("Forwarding your call to Refound...");<br />            call.Solved = true;<br />            return call;<br />        }<br /><br />        return base.Handle(call);<br />    }<br />}<br /><br />class MarketingHandler : BaseHandler<br />{<br />    public override Call Handle(Call call)<br />    {<br />        if (call.Option == 3)<br />        {<br />            Console.WriteLine("Forwarding your call to Marketing...");<br />            call.Solved = true;<br />            return call;<br />        }<br /><br />        return base.Handle(call);<br />    }<br />}<br /><br />class OtherHandler : BaseHandler<br />{<br />    public override Call Handle(Call call)<br />    {<br />        Console.WriteLine("Forwarding your call to another sector...");<br />        call.Solved = true;<br />        return call;<br />    }<br />}<br />```<br /><br />### Command<br /><br />Encapsulates a command request as an object, supporting undoable operations.<br /><br />> With this pattern, instead of just perform some action, it's possible to wrap that action in a command and make sure it is undoable.<br /><br />**Uses:**<br />- Automation<br />- Request Queues<br />- Editors<br />- Do & Undo Operations<br />- Macro Commands<br /><br />**UML:**<br /><br />![command](https://user-images.githubusercontent.com/72560319/159564163-dc0e989b-49e8-4fda-9c7b-b0e0f7e3f1b9.png)<br /><br />**In C#:**<br />```cs<br />public class Program<br />{<br />    public static void Main()<br />    {<br />        var receiver = new Light();<br />        var invoker = new RemoteControl(<br />                        new LightOnCommand(receiver),<br />                        new LightOnCommand(receiver),<br />                        new LightOffCommand(receiver),<br />                        new LightOffCommand(receiver)<br />                      );<br />    }<br />}<br /><br />class RemoteControl // Invoker<br />{<br />    public RemoteControl(ICommand on, ICommand up, ICommand down, ICommand off)<br />    {<br />        On = on;<br />        Up = up;<br />        Down = down;<br />        Off = off;<br />    }<br /><br />    private ICommand On { get; set; }<br />    private ICommand Up { get; set; }<br />    private ICommand Down { get; set; }<br />    private ICommand Off { get; set; }<br /><br />    public void ClickOn() => On.Execute();<br />    public void ClickOff() => Off.Execute();<br />}<br /><br />interface ICommand<br />{<br />    void Execute();<br />    void Unexecute();<br />}<br /><br />class LightOnCommand : ICommand<br />{<br />    public LightOnCommand(Light light)<br />    {<br />        Light = light;<br />    }<br /><br />    public Light Light { get; set; }<br /><br />    public void Execute() => Light.On();<br />    public void Unexecute() => Light.Off();<br />}<br /><br />class LightOffCommand : ICommand<br />{<br />    public LightOffCommand(Light light)<br />    {<br />        Light = light;<br />    }<br /><br />    public Light Light { get; set; }<br /><br />    public void Execute() => Light.Off();<br />    public void Unexecute() => Light.On();<br />}<br /><br />class Light // Receiver<br />{<br />    public void On() { }<br />    public void Off() { }<br />}<br />```<br /><br />### Interpreter<br /><br />A way to include language elements in a program.<br /><br />### Iterator<br /><br />Sequentially access the elements of a collection, without exposing its underlying representation, that is, not exposing all the items right away.<br /><br />> Some benefits of iterator pattern is that is possible to create infinite collections and to pause the iteration to continue it later in a much easier way than `foreach`s with an index.<br /><br />**Uses:**<br />- Custom Collections<br />- Games<br /><br />**UML:**<br /><br />![iterator](https://user-images.githubusercontent.com/72560319/159944504-30077262-791e-433d-80c7-f25f24322081.png)<br /><br />**In C#:**<br />```cs<br />public class Program<br />{<br />    public static void Main()<br />    {<br />        var handHeldInventory = new HandHeldInventory(new FoodItem(1, "Apple", 20.00), new WeaponIem(2, "Sword", 60.00));<br />        var handItor = handHeldInventory.GetIterator();<br /><br />        while (!handItor.IsDone()) // Abstraction<br />        {<br />            Console.WriteLine(handItor.Current());<br />            handItor.Next();<br />        }        <br />        <br />        var backpackInventory = new BackpackInventory(new FoodItem(1, "Apple", 20.00), new FoodItem(1, "Bread", 40.00), new WeaponIem(2, "Sword", 60.00));<br />        var backpackItor = backpackInventory.GetIterator();<br /><br />        while (!backpackItor.IsDone()) // Same abstraction<br />        {<br />            Console.WriteLine(backpackItor.Current());<br />            backpackItor.Next();<br />        }<br />    }<br />}<br /><br />// Items<br />interface IItem<br />{<br />    uint Id { get; set; }<br />    string Name { get; set; }<br />}<br /><br />class FoodItem : IItem<br />{<br />    public FoodItem(uint id, string name, double regeneration)<br />    {<br />        Id = id;<br />        Name = name;<br />        Regeneration = regeneration;<br />    }<br /><br />    public uint Id { get; set; }<br />    public string Name { get; set; }<br />    public double Regeneration { get; set; }<br />}<br /><br />class WeaponIem : IItem<br />{<br />    public WeaponIem(uint id, string name, double damage)<br />    {<br />        Id = id;<br />        Name = name;<br />        Damage = damage;<br />    }<br /><br />    public uint Id { get; set; }<br />    public string Name { get; set; }<br />    public double Damage { get; set; }<br />}<br /><br />// Iterables<br />interface IInventory<br />{<br />    IInventoryIterator GetIterator();<br />}<br /><br />class HandHeldInventory : IInventory<br />{<br />    public HandHeldInventory(IItem leftItem, IItem rightItem)<br />    {<br />        LeftItem = leftItem;<br />        RightItem = rightItem;<br />    }<br /><br />    public IItem LeftItem { get; set; }<br />    public IItem RightItem { get; set; }<br /><br />    public IInventoryIterator GetIterator() => new HandHeldInventoryIterator(this); // Factory Method<br />}<br /><br />class BackpackInventory : IInventory<br />{<br />    public BackpackInventory(IItem item1, IItem item2, IItem item3)<br />    {<br />        Item1 = item1;<br />        Item2 = item2;<br />        Item3 = item3;<br />    }<br /><br />    public IItem Item1 { get; set; }<br />    public IItem Item2 { get; set; }<br />    public IItem Item3 { get; set; }<br />    // ...<br /><br />    public IInventoryIterator GetIterator() => new HandHeldInventoryIterator(this); // Factory Method<br />}<br /><br />// Iterators<br />interface IInventoryIterator<br />{<br />    bool IsDone();<br />    void Next();<br />    IItem? Current();<br />}<br /><br />class HandHeldInventoryIterator : IInventoryIterator<br />{<br />    public HandHeldInventoryIterator(HandHeldInventory inventory)<br />    {<br />        _inventory = inventory;<br />    }<br /><br />    private HandHeldInventory _inventory { get; set; } // Iterable<br />    private uint _index = 0;<br /><br />    public bool IsDone() => _index < 2;<br />    public void Next() => _index++;<br />    public IItem? Current()<br />    {<br />        switch (_index)<br />        {<br />            case 0:<br />                return _inventory.LeftItem;<br />            case 1:<br />                return _inventory.RightItem;<br />            default:<br />                return null;<br />        }<br />    }<br />}<br /><br />class BackpackInventoryIterator : IInventoryIterator<br />{<br />    public BackpackInventoryIterator(BackpackInventory inventory)<br />    {<br />        _inventory = inventory;<br />    }<br /><br />    private BackpackInventory _inventory { get; set; } // Iterable<br />    private uint _index = 0;<br /><br />    public bool IsDone() => _index < 3;<br />    public void Next() => _index++;<br />    public IItem? Current()<br />    {<br />        switch (_index)<br />        {<br />            case 0:<br />                return _inventory.Item1;<br />            case 1:<br />                return _inventory.Item2;<br />            case 2:<br />                return _inventory.Item3;<br />            default:<br />                return null;<br />        }<br />    }<br />}<br />```<br />#### Null Iterator<br /><br />> *For better undestanding, check the [Null Object Pattern](#null-object)*.<br /><br />Defines an always null iterator.<br /><br />**Uses:**<br />- Component Leaves (Composite Pattern)<br />- Null States (State Pattern)<br /><br />**In C#:**<br />```cs<br />class NullIterator : IIterator<br />{<br />    public NullIterator(IIterable iterable)<br />    {<br />        _iterable = iterable;<br />    }<br /><br />    private IIterable _iterable { get; set; }<br />    private uint _index = 0;<br /><br />    public bool IsDone() => true;<br />    public void Next() { }<br />    public IItem? Current() => null;<br />}<br />```<br /><br />### Mediator<br /><br />Defines simplified communication between classes.<br /><br />### Memento<br /><br />Capture and restore an object's internal state.<br /><br />### State<br /><br />Alter an object's behavior at runtime when its internal state changes.<br /><br />> The state is not an enum or property, it is an object. Therefore, it replaces a conditional with polymorphism.<br /><br />**Uses:**<br />- Network Requests<br />- UI Components<br />- No-Memory Machines<br /><br />![state-example](https://user-images.githubusercontent.com/72560319/159712767-c29a028c-22a5-4be6-9a2d-7390e533e2a8.png)<br /><br />**UML:**<br /><br />![state](https://user-images.githubusercontent.com/72560319/159712692-cf90884f-1bee-475d-94d7-e02a630e9bec.png)<br /><br />**In C#:**<br />```cs<br />class Gate<br />{<br />    public Gate(IGateState initialState)<br />    {<br />        State = initialState;<br />    }<br /><br />    public IGateState State { get; set; }<br /><br />    public void Enter() => State = State.Enter(); <br />    public void Pay() => State = State.Pay(); <br />    public void PayOk() => State = State.PayOk(); <br />    public void PayFailed() => State = State.PayFailed(); <br />}<br /><br />interface IGateState<br />{<br />    IGateState Enter();<br />    IGateState Pay();<br />    IGateState PayOk();<br />    IGateState PayFailed();<br />}<br /><br />class ClosedGateState : IGateState<br />{<br />    public IGateState Enter() => new ClosedGateState();<br />    public IGateState Pay() => new ProcessingPaymentGateState();<br />    public IGateState PayOk() => new ClosedGateState();<br />    public IGateState PayFailed() => new ClosedGateState();<br />}<br /><br />class ProcessingPaymentGateState : IGateState<br />{<br />    public IGateState Enter() => new ProcessingPaymentGateState();<br />    public IGateState Pay() => new ProcessingPaymentGateState();<br />    public IGateState PayOk() => new OpenGateState();<br />    public IGateState PayFailed() => new ClosedGateState();<br />}<br /><br />class OpenGateState : IGateState<br />{<br />    public IGateState Enter() => new ClosedGateState();<br />    public IGateState Pay() => new OpenGateState();<br />    public IGateState PayOk() => new OpenGateState();<br />    public IGateState PayFailed() => new OpenGateState();<br />}<br />```<br /><br />### Observer<br /><br />Defines an one to many dependency between objects, so that when the observable changes state all of its dependecies are notified and updated automatically.<br /><br />> *The observable is the object that changes and the observers are the objects interested in the observable changes.*<br /><br />**Uses:**<br />- Chats<br />- Sensors<br />- Newsletters<br />- Notifications<br /><br />**UML:**<br /><br />![observer](https://user-images.githubusercontent.com/72560319/159771101-5af99680-3192-430e-ac3e-ff87cc54c350.png)<br /><br />**In C#:**<br />```cs<br />public class Program<br />{<br />	public static void Main()<br />	{<br />		var station = new WeatherStation();<br />		station.Add(new PhoneDisplay(station));<br />		station.Add(new WindowDisplay(station));<br />	}<br />}<br /><br />interface IObservable<br />{<br />    List<IObserver> Observers { get; }<br /><br />    void Add(IObserver observer);<br />    void Remove(IObserver observer);<br />    void Notify();<br />}<br /><br />class WeatherStation : IObservable<br />{<br />    public WeatherStation()<br />    {<br />        Observers = new List<IObserver> { };<br />    }<br /><br />    public List<IObserver> Observers { get; private set; }<br /><br />    private decimal _temperature { get; set; }<br />    public decimal Temperature<br />    {<br />        get => _temperature;<br />        set <br />        { <br />            _temperature = value;<br />            Notify();<br />        }<br />    }<br /><br />    private decimal _humidity { get; set; }<br />    public decimal Humidity<br />    {<br />        get => _humidity;<br />        set<br />        {<br />            _humidity = value;<br />            Notify();<br />        }<br />    }<br /><br />    public void Add(IObserver observer) => Observers.Add(observer);<br />    public void Remove(IObserver observer) => Observers.Remove(observer);<br />    public void Notify() => Observers.ForEach(o => o.Update());<br />}<br /><br />interface IObserver<br />{<br />    void Update();<br />}<br /><br />class PhoneDisplay : IObserver<br />{<br />    public PhoneDisplay(WeatherStation station)<br />    {<br />        Station = station;<br />    }<br /><br />    public WeatherStation Station { get; init; }<br />    public decimal Temperature { get; private set; } // Only this state matters for this object<br /><br />    public void Update() <br />    {<br />        if (Temperature != Station.Temperature)<br />        {<br />            Temperature = Station.Temperature;<br />            Display();<br />        }<br />    }<br /><br />    public void Display() { } // Refreshes temperature on display<br />}<br /><br />class WindowDisplay : IObserver<br />{<br />    public WindowDisplay(WeatherStation station)<br />    {<br />        Station = station;<br />    }<br /><br />    public WeatherStation Station { get; init; }<br />    public decimal Humidity { get; private set; } // Only this state matters for this object<br /><br />    public void Update()<br />    {<br />        if (Humidity != Station.Humidity)<br />        {<br />            Humidity = Station.Humidity;<br />            Display();<br />        }<br />    }<br /><br />    public void Display() { } // Refreshes humidity on display<br />}<br />```<br /><br />### Strategy<br /><br />Encapsulates an algorithm inside a class and allows that a class behavior or its algorithm can be changed at runtime.<br /><br />> *The strategy pattern is about using composition and dependency injection instead of inheritance.*<br /><br />> *This pattern is useful to encapsulate business rules, once it can remove the need of subclasses and transform abstract classes into normal classes.*<br /><br />**Uses:**<br />- Ecommerces<br />- Finances<br />- Law<br /><br />**UML:**<br /><br />![strategy](https://user-images.githubusercontent.com/72560319/159779934-01d3c83e-a469-4b82-812f-d52cb7e443fb.png)<br /><br />**In C#:**<br />```cs<br />public class Program<br />{<br />    public static void Main()<br />    {<br />        var cityDuck = new Duck(new SimpleQuacking(), new SimpleFlying(), new DisplayAsText());<br />        var wildDuck = new Duck(new SimpleQuacking(), new JetFlying(), new DisplayAsGraphics());<br />        var mountainDuck = new Duck(new SimpleQuacking(), new JetFlying(), new DisplayAsText());<br />        var rubberDuck = new Duck(new NoQuacking(), new SimpleFlying(), new DisplayAsGraphics());<br />    }<br />}<br /><br />class Duck<br />{<br />    public Duck(IQuackBehaviour quackBehaviour, IFlyBehaviour flyBehaviour, IDisplayBehaviour displayBehaviour)<br />    {<br />        QuackBehaviour = quackBehaviour;<br />        FlyBehaviour = flyBehaviour;<br />        DisplayBehaviour = displayBehaviour;<br />    }<br /><br />    public IQuackBehaviour QuackBehaviour { get; set; }<br />    public IFlyBehaviour FlyBehaviour { get; set; }<br />    public IDisplayBehaviour DisplayBehaviour { get; set; }<br /><br />    public void Quack() => QuackBehaviour.Quack();<br />    public void Fly() => FlyBehaviour.Fly();<br />    public void Display() => DisplayBehaviour.Display();<br />}<br /><br />interface IQuackBehaviour<br />{<br />    void Quack();<br />}<br /><br />class SimpleQuacking : IQuackBehaviour<br />{<br />    public void Quack()<br />    {<br />        // Logic<br />    }<br />}<br /><br />class NoQuacking : IQuackBehaviour<br />{<br />    public void Quack()<br />    {<br />        // Logic<br />    }<br />}<br /><br />interface IFlyBehaviour<br />{<br />    void Fly();<br />}<br /><br />class SimpleFlying : IFlyBehaviour<br />{<br />    public void Fly()<br />    {<br />        // Logic<br />    }<br />}<br /><br />class JetFlying : IFlyBehaviour<br />{<br />    public void Fly()<br />    {<br />        // Logic<br />    }<br />}<br /><br />interface IDisplayBehaviour<br />{<br />    void Display();<br />}<br /><br />class DisplayAsText : IDisplayBehaviour<br />{<br />    public void Display()<br />    {<br />        // Logic<br />    }<br />}<br /><br />class DisplayAsGraphics : IDisplayBehaviour<br />{<br />    public void Display()<br />    {<br />        // Logic<br />    }<br />}<br />```<br /><br />### Template Method<br /><br />Defer the exact steps of an algorithm to a subclass, working as a blueprint for methods.<br /><br />> *Template method pattern works better in cases where strategy doesn't fit and there is fixed logic on the template. Anyway, it can be very dangerous given that it uses inheritance over composition.*<br /><br />> *A template method class is composed by a defined method (template method) and the empty methods (hooks) that are called inside the template method.*<br /><br />> *This pattern is similitar to inversion of dependency pattern, like the Hollywood principle: "Don't call us, we'll call you. Or not."* <br /><br />**Uses:**<br />- Frameworks<br />- Database Operations<br /><br />**UML:**<br /><br />![template-method](https://user-images.githubusercontent.com/72560319/159915346-6633ca6f-0198-43cb-b041-3090c50ebe83.png)<br /><br />**In C#:**<br />```cs<br />abstract class Record<br />{<br />    public void Save()<br />    {<br />        Validate();<br />        BeforeSave();<br />        // Save to DB<br />        AfterSave();<br />    }<br /><br />    // Hooks<br />    public virtual void Validate() { }<br />    public virtual void BeforeSave() { }<br />    public virtual void AfterSave() { }<br />}<br /><br />class UserRecord : Record<br />{<br />    public override void Validate()<br />    {<br />        // Logic<br />    }<br /><br />    public override void BeforeSave()<br />    {<br />        // Logic<br />    }<br />}<br /><br />class PostRecord : Record<br />{<br />    public override void Validate()<br />    {<br />        // Logic<br />    }<br /><br />    public override void AfterSave()<br />    {<br />        // Logic<br />    }<br />}<br />```<br /><br />### Visitor<br /><br />Defines a new operation to a class without change.<br /><br />## Other Patterns<br /><br />### Null Object<br /><br />Designed to act as a default value of an object, working as a null state.<br /><br />> *This pattern make it possible to handle nullness in the same way that somethingness is handled.*<br /><br />### Honorable Mentions<br /><br />-   **Dependency Injection**<br />-   **Inversion of Control**<br />-   **Inversion of Dependency**<br />-   **Lazy Loading**<br />-   **Object Pool:** avoid expensive acquisition and release of resources by recycling objects that are no longer in use<br />- **Private Class Data:** restricts accessor/mutator access.<br />-   **Mock Object**<br />-   **Rules Design Patterns**<br />-   **Intercepting Filter**<br />-   **Method Chaining**<br />-   **Unit of Work**<br /><br />|# Design Patterns<br /><br />- [Design Patterns](#design-patterns)<br />  * [Creational Design Patterns](#creational-design-patterns)<br />    + [Factory Method](#factory-method)<br />    + [Abstract Factory](#abstract-factory)<br />    + [Builder](#builder)<br />    + [Prototype](#prototype)<br />    + [Singleton](#singleton)<br />      - [Monostate...](#monostate)<br />  * [Structural Design Patterns](#structural-design-patterns)<br />    + [Adapter](#adapter)<br />    + [Bridge](#bridge)<br />    + [Facade](#facade)<br />      - [Law of Demeter (Principle of Least Knowledge)](#law-of-demeter--principle-of-least-knowledge-)<br />    + [Proxy](#proxy)<br />    + [Decorator](#decorator)<br />    + [Composite](#composite)<br />    + [Flyweight](#flyweight)<br />  * [Behavioral Patterns](#behavioral-patterns)<br />    + [Chain of Responsibility](#chain-of-responsibility)<br />    + [Command](#command)<br />    + [Interpreter](#interpreter)<br />    + [Iterator](#iterator)<br />      - [Null Iterator](#null-iterator)<br />    + [Mediator](#mediator)<br />    + [Memento](#memento)<br />    + [State](#state)<br />    + [Observer](#observer)<br />    + [Strategy](#strategy)<br />    + [Template Method](#template-method)<br />    + [Visitor](#visitor)<br />  * [Other Patterns](#other-patterns)<br />    + [Null Object](#null-object)<br />    + [Honorable Mentions](#honorable-mentions)<br /><br /><small><i><a href='http://ecotrust-canada.github.io/markdown-toc/'>Table of contents generated with markdown-toc</a></i></small><br /><br /><br />## Creational Design Patterns<br /><br />###  Factory Method<br /><br />Creates an instance of several derived classes.<br /><br />> *Abstract the instantiation of objects by wrapping them in a Factory method.*<br /><br />**Uses:**<br />- Frameworks<br />- TDD<br /><br />**UML:**<br /><br />![factory-method](https://user-images.githubusercontent.com/72560319/159106269-6a0b440f-ad84-4f1b-bc60-9252db988268.png)<br /><br />**In C#:**<br />```cs<br />public class Program<br />{<br />	public static void Main()<br />	{<br />		var animal1 = new BalancedAnimalFactory().CreateAnimal();<br />		var animal2 = new RandomAnimalFactory().CreateAnimal();<br />	}<br />}<br />	<br />public abstract class Animal { }<br /><br />public class Dog : Animal { }<br />public class Cat : Animal { }<br />public class Duck : Animal { }<br /><br />public interface IAnimalFactory <br />{<br />	public Animal CreateAnimal();<br />}<br /><br />public class BalancedAnimalFactory : IAnimalFactory<br />{<br />	public Animal CreateAnimal()<br />	{<br />		// Logic<br />		return new Dog();<br />	}<br />}<br /><br />public class RandomAnimalFactory : IAnimalFactory<br />{<br />	public Animal CreateAnimal()<br />	{<br />		// Logic<br />		return new Cat();<br />	}<br />}<br />```<br /><br />**In TypeScript:**<br />```ts<br />    function fabricatePerson(name, lastname) {<br />        let person = {}<br />        person.name = name<br />        person.lastname = lastname<br />            <br />        function fullName() {<br />    	    return `${person.name} ${person.lastname}`<br />        }<br /><br />		person.fullName<br />        <br />        return person<br />    }<br />```<br /><br />###  Abstract Factory<br /><br />Create an object without exposing the creation logic to the client and refer to newly created object using a common interface.<br /><br />**Uses:**<br />- UI Controls<br />- Multiplatform Toolkits<br />- Product Families<br /><br />**UML:** <br /><br />![abstract-factory](https://user-images.githubusercontent.com/72560319/159106388-4cc123cf-d58e-4857-8d55-921cf0a3bd78.png)<br /><br />**In C#:**<br />```cs<br />public class Program<br />{<br />	public static void Main()<br />	{<br />		new NavigationBar(new Android());<br />		new DropdownMenu(new Android());<br />	}<br />}<br /><br />public class Button<br />{<br />	public string Type { get; set; }<br />}<br /><br />public interface IUIFactory<br />{<br />	public Button CreateButton();<br />}<br /><br />public class Apple : IUIFactory<br />{<br />	public Button CreateButton()<br />	{<br />		return new Button { Type = "iOS Button".Dump() };<br />	}<br />}<br /><br />public class Android : IUIFactory<br />{<br />	public Button CreateButton()<br />	{<br />		return new Button { Type = "Android Button".Dump() };<br />	}<br />}<br /><br />public class NavigationBar<br />{<br />	public NavigationBar(IUIFactory factory) => factory.CreateButton();<br />}<br /><br />public class DropdownMenu<br />{<br />	public DropdownMenu(IUIFactory factory) => factory.CreateButton();<br />}<br />```<br /><br />**In TypeScript:**<br />```ts<br />    abstract class Animal {}<br />    <br />    abstract class Bird extends Animal {}<br />    <br />    abstract class Reptile extends Animal {}<br />    <br />    class Hawk extends Bird {}<br />    <br />    class Alligator extends Reptile {}<br />```<br /><br />###  Builder<br /><br />Separates object construction from its representation. <br /><br />A `Builder` abstract class or interface and one `ConcreteBuilder` for each variation of the product.<br /><br />**Uses:**<br />- Templates<br />- Text Editors<br /><br />**In TypeScript:**<br />```ts<br />    var Task = (name, description, finished, dueDate) => {<br />        this.name = name<br />        this.description = description<br />        this.finished = finished<br />        this.dueDate = dueDate<br />    }<br />    <br />    var TaskBuilder = () => {    <br />        let name<br />        let description<br />        let isFinished = false<br />        let dueDate<br />    <br />        return {<br />            setName: name => {<br />                this.name = name<br />                return this<br />            },<br />            setDescription: description => {<br />                this.description = description<br />                return this<br />            },<br />            setFinished: finished => {<br />                this.finished = finished<br />                return this<br />            },<br />            setDueDate: dueDate => {<br />                this.dueDate = dueDate<br />                return this<br />            },<br />            build: () => {<br />                return new Task(name, description, isFinished, dueDate)<br />            }<br />        }<br />    }<br />    <br />    let task = new TaskBuilder().setName('Task A').setDescription('finish book')<br />        .setDueDate(new Date(2019, 5, 12))<br />```<br />    <br />###  Prototype<br /><br />A fully initialized instance to be copied or cloned and then modified.<br /><br />**Uses:**<br />- Avoid unnecessary subclasses<br />- JavaScript and TypeScript<br /><br />**In TypeScript:**<br />```ts<br />    interface Prototype {<br />        clone(): Prototype<br />    }<br />    <br />    class Person implements Prototype {<br />        constructor(public name: string, public age: number) {}<br />    	<br />        clone(): this {<br />            const newPerson = Object.create(this)<br />            return newPerson<br />        }<br />    }<br />    <br />    const person1 = new Person('Luiz', 30)<br />    const person2 = person1.clone()<br />```<br /><br />###  Singleton<br /><br />A class of which only a single instance can exist and that provides a global access to itl. <br /><br />All singletons have a private constructor (`createInstance`), a public access method (`getInstance`) and a static attribute (`instance`).<br /><br />> If possible, avoid singletons at all. They can be very tricky to escalate and to work with TDD, as one man's constant is one man's variable.<br /><br />> In a way, it's completely fine to have a single object within an application, but it isn't to make it impossible to create a second instance.<br /><br />**Uses:**<br />- Database Configuration<br /><br />**UML:**<br /><br />![singleton](https://user-images.githubusercontent.com/72560319/159556077-69285a0d-d32d-4b24-ad8f-b8a8a1f301b8.png)<br /><br />**In C#:**<br />```cs<br />class Singleton<br />{<br />    private Singleton() { }<br /><br />    private static Singleton? Instance;<br /><br />    public static void GetInstance()<br />    {<br />        if (Instance == null)<br />            Instance = new Singleton();<br />    }<br />}<br />```<br /><br />**In TypeScript:**<br />```ts<br />    const database = (() => {<br />        var instance<br />    <br />        function createInstance() {<br />            var object = new Object("I am the instance")<br />            return object<br />        }<br />    <br />        return {<br />            getInstance: () => {<br />                if (!instance) instance = createInstance()<br />                return instance<br />        	}<br />        }<br />    })()<br />```<br /><br />#### Monostate...<br /><br />Respects the S.O.L.I.D principles.<br /><br />## Structural Design Patterns<br /><br />### Adapter<br /><br />Match interfaces of different classes, working as a wrapper. With an adapter, change the underline behaviour is not necessary.<br /><br />> *It's useful when you don't want your code to directly depend on third party code or legacy, uncoupling your code.*<br /><br />> **Changes the interface** but **doesn't change the implementation**.<br /><br />**Uses:**<br />- Frameworks<br />- External Libraries<br />- Legacy Codes<br /><br />**UML:**<br /><br />![adapter](https://user-images.githubusercontent.com/72560319/159727140-5ee62fd8-c556-47d4-b8e8-b2138c76c243.png)<br /><br />**In C#:**<br />```cs<br />public class Program<br />{<br />	public static void Main()<br />	{<br />		var target = new Adapter(new Adaptee());<br />		target.Request();<br />	}<br />}<br /><br />class Adaptee<br />{<br />	public void SpecificRequest()<br />	{<br />		// Logic<br />	}<br />}<br /><br />interface ITarget<br />{<br />	void Request();<br />} <br /><br />class Adapter : ITarget<br />{<br />	public Adapter(Adaptee a)<br />	{<br />		Adaptee = a;<br />	}<br />	<br />	public Adaptee Adaptee { get; set; }<br />	<br />	public void Request()<br />	{<br />		// Logic to adapt the method<br />		Adaptee.SpecficRequest();<br />	}<br />} <br />```<br /><br />**In TypeScript:**<br />```ts<br />> main.ts<br /><br />    import {<br />      EmailValidatorProtocol,<br />      EmailValidatorFnProtocol,<br />    } from './validation/email-validator-protocol'<br />    import { EmailValidatorClassAdapter } from './validation/email-validator-class-adapter'<br />    import { emailValidatorFnAdapter } from './validation/email-validator-fn-adapter'<br />    <br />    function validaEmailClass(<br />      emailValidator: EmailValidatorProtocol,<br />      email: string,<br />    ): void {<br />      if (emailValidator.isEmail(email)) {<br />        console.log('Email é válido (CLASS)')<br />      } else {<br />        console.log('Email é inválido (CLASS)')<br />      }<br />    }<br />    <br />    function validaEmailFn(<br />      emailValidator: EmailValidatorFnProtocol,<br />      email: string,<br />    ): void {<br />      if (emailValidator(email)) {<br />        console.log('Email é válido (FN)')<br />      } else {<br />        console.log('Email é inválido (FN)')<br />      }<br />    }<br />    <br />    const email = 'luizomf@gmail.com'<br />    validaEmailClass(new EmailValidatorClassAdapter(), email)<br />    validaEmailFn(emailValidatorFnAdapter, email)<br /><br />> email-validator-protocol.ts<br /><br />    export interface EmailValidatorProtocol {<br />      isEmail: EmailValidatorFnProtocol<br />    }<br />    <br />    export interface EmailValidatorFnProtocol {<br />      (value: string): boolean<br />    }<br /><br />> email-validator-class-adapter.ts<br /><br />    import isEmail from 'validator/lib/isEmail'<br />    import { EmailValidatorProtocol } from './email-validator-protocol'<br />    <br />    export class EmailValidatorClassAdapter implements EmailValidatorProtocol {<br />      isEmail(value: string): boolean {<br />        return isEmail(value)<br />      }<br />    }<br /><br />> email-validator-fn-adapter.ts<br /><br />    import isEmail from 'validator/lib/isEmail'<br />    import { EmailValidatorFnProtocol } from './email-validator-protocol'<br />    <br />    export const emailValidatorFnAdapter: EmailValidatorFnProtocol = (<br />      value: string,<br />    ): boolean => {<br />      return isEmail(value)<br />    }<br />```<br /><br />### Bridge<br /><br />Separates an object’s interface / abstraction from its implementation, so that the both can vary and evolve independently.<br /><br />> *Different from the adapter pattern, the bridge pattern is usually used before the project started, while the adapter is used after the project is already ongoing.*<br /><br />**Uses:**<br />- Frameworks<br />- External Libraries<br />- Legacy Codes<br /><br />**UML:**<br /><br />![bridge-pattern](https://user-images.githubusercontent.com/72560319/159353103-75e0b64a-b72e-46bf-bb00-c9fbd4f7a080.png)<br /><br />**In C#:**<br />```cs<br />abstract class View<br />{<br />	public View(IMediaResource mediaResource)<br />	{<br />		MediaResource = mediaResource;<br />	}<br />	<br />	public IMediaResource MediaResource;<br /><br />	public virtual string Show() { return "html"; }<br />}<br /><br />class ShortFormView : View<br />{<br />    public ShortFormView(IMediaResource mediaResource) : base(mediaResource)<br />    {<br />		MediaResource = mediaResource;<br />	}<br /><br />    public override string Show()<br />	{<br />		// Logic<br />		// MediaResource.Snippet;<br />		return "html";<br />	}<br />}<br /><br />class LongFormView : View<br />{<br />	public LongFormView(IMediaResource mediaResource) : base(mediaResource)<br />	{<br />		MediaResource = mediaResource;<br />	}<br /><br />	public override string Show()<br />	{<br />		// Logic<br />		// MediaResource.Snippet;<br />		return "html";<br />	}<br />}<br /><br />interface IMediaResource<br />{<br />	string Snippet { get; }<br />}<br /><br />class ArtistResource<br />{<br />	public ArtistResource(string bio)<br />    {<br />        Bio = bio;<br />    }<br />    <br />	public string Bio { get; set; }<br />}<br /><br />class ArtistAdapter : IMediaResource<br />{<br />	public ArtistAdapter(ArtistResource artistResource)<br />	{<br />		ArtistResource = artistResource;<br />	}<br />	<br />	public ArtistResource ArtistResource { get; set; }<br />	public string Snippet => ArtistResource.Bio;<br />}<br /><br />class BookResource<br />{<br />	public BookResource(string coverText)<br />    {<br />        CoverText = coverText;<br />    }<br />    <br />	public string CoverText { get; set; }<br />}<br /><br />class BookAdapter : IMediaResource<br />{<br />	public BookAdapter(BookResource bookResource)<br />	{<br />		BookResource = bookResource;<br />	}<br />	<br />	public BookResource BookResource { get; set; }<br />	public string Snippet => BookResource.CoverText;<br />}<br />```<br /><br />### Facade<br /><br />A single class (`wrapper`) that represents an entire subsystem in higher level. A facade helps to simply and unify a program.<br /><br />> High-level level abstraction over low-level components, where the **interface is changed** and the **implementation is not**.<br /><br />**Uses:**<br />- Operational Systems<br />- Compilers<br />- Complex Programs<br /><br />#### Law of Demeter (Principle of Least Knowledge)<br /><br />An object should never know the internal details of other objects.<br /><br />> By this, ```a().b().c()``` isn't correct, however ```a().b()``` is. <br /><br />**UML:**<br /><br />![facade](https://user-images.githubusercontent.com/72560319/159728186-1c2659b3-5f89-43d5-beec-2c67ca9b71c0.png)<br /><br />**In TypeScript:**<br />```ts<br />> customer-facade.ts<br /><br />    import { CustomerClient } from '../models/customer-client.ts'<br />    import { CustomerAvatar } from '../models/customer-avatar.ts'<br />    import { CustomerDocuments } from '../models/customer-documents.ts'<br />    import { CustomerAccessHistory } from '../models/customer-access-history.ts'<br />    import { CustomerService } from '../models/customer-service.ts'<br />    import { CustomerEmail } from '../models/customer-email.ts'<br />     <br />    export module Facade { <br />        export class CustomerFacade { <br />            static removeAccount(customer: Customer) {<br />                const customerAvatar = new CustomerAvatar(customer)<br />                const customerDocumentos = new CustomerDocuments(customer)<br />                const customerHistoricoAcesso = new CustomerAccessHistory(customer)<br />                const customerService = new CustomerService(customer)<br />                const customerEmail = new CustomerEmail(customer)<br />    <br />                customerAvatar.remove()<br />                customerDocumentos.delete()<br />                customerHistoricoAcesso.remove()<br />                customerService.delete()<br />                customerEmail.sendRemoveAccount()<br />            }<br />        }<br />    }<br /><br />> main.ts<br /><br />    import { CustomerClient } from '../models/customer-client.ts'<br />    import { Facade } from './facade/customer-facade.ts'<br />    <br />    const John = new Customer(<br />        "John Holts",<br />        "johnholts",<br />        "johnholts67@hotmail.com"<br />    )<br />    <br />    const Alice = new Customer(<br />        "Alice Cooper",<br />        "alicecooper",<br />        "alicecooperw@gmail.com"<br />    )<br />    <br />    Facade.CustomerFacade.removeAccount(John)<br />    Facade.CustomerFacade.removeAccount(Alice)<br />```<br /><br />### Proxy<br /><br />Provide a surrogate or placeholder for another object to control access to it, working as a middleware and adding a level of indirection.<br /><br />> *There is remote proxies (different context), virtual proxies (expensive crafting resources) and protection proxies (access management).*<br /><br />> **Changes the implementation** but **doesn't change the interface**.<br /><br />**Uses:**<br />- Networking<br />- VPNs<br />- Credit card validations<br />- Cache<br />- Logging<br /><br />**UML:**<br /><br />![proxy](https://user-images.githubusercontent.com/72560319/159519195-b962a1b8-2da4-48d3-88ff-8d464bd113a7.png)<br /><br />**In C#:**<br />```cs<br />interface IBookParser<br />{<br />    string Book { get; set; } <br />    int GetNumPages();<br />}<br /><br />class BookParser : IBookParser<br />{<br />    public BookParser(string book)<br />    {<br />        // Expensive parsing<br />        Book = book;<br />    }<br /><br />    public string Book { get; set; }<br /><br />    public int GetNumPages() => 0; // get the number of pages<br />}<br /><br />class LazyBookParserProxy : IBookParser<br />{<br />    public LazyBookParserProxy(string book)<br />    {<br />        BookParser = null;<br />        Book = book;<br />    }<br /><br />    private BookParser? BookParser;<br />    public string Book { get; set; }<br /><br />    public int GetNumPages()<br />    {<br />        if (BookParser == null)<br />            return 0;<br /><br />        BookParser = new BookParser(Book);<br />        return BookParser.GetNumPages();<br />    }<br />}<br />```<br /><br />**In TypeScript:**<br />```ts<br />    export interface Subject { <br />        request(): void<br />    } <br />    <br />    export class RealSubject implements Subject { <br />        request(): void { <br />            console.log('Something that the object do.')<br />        } <br />    } <br />    <br />    export class Proxy implements Subject { <br />        constructor(private subject: Subject) {} <br />    <br />        request(): void { <br />            console.log('The proxy do something')<br />            this.subject.request()<br />            console.log('The proxy can do other thing')<br />        } <br />    }<br />```<br /><br />### Decorator<br /><br />Add responsibilities and behaviours to objects dynamically at runtime wrapping them without the need to change them.<br /><br />> *The decorator pattern is useful to add features to existent code.*<br /><br />> **Changes the implementation** but **doesn't change the interface**.<br /><br />**Uses:**<br />- Cache<br />- Logging<br /><br />**UML:**<br /><br />![decorator](https://user-images.githubusercontent.com/72560319/159546636-9b279668-9f9d-40db-a87a-888dd913b008.png)<br /><br />**In C#:**<br />```cs<br />public class Program<br />{<br />    public static void Main()<br />    {<br />        var coffe = new CaramelDecorator(new ChocolateDecorator(new Expresso()));<br />    }<br />}<br /><br />interface IBeverage<br />{<br />    decimal Cost();<br />}<br /><br />class Decaf : IBeverage<br />{<br />    public decimal Cost() => 1.10m;<br />}<br /><br />class Expresso : IBeverage<br />{<br />    public decimal Cost() => 1.00m;<br />}<br /><br />interface IAdditionDecorator : IBeverage<br />{<br />    IBeverage Beverage { get; set; }<br />}<br /><br />class CaramelDecorator : IAdditionDecorator<br />{<br />    public CaramelDecorator(IBeverage beverage)<br />    {<br />        Beverage = beverage;<br />    }<br /><br />    public IBeverage Beverage { get; set; }<br /><br />    public decimal Cost() => Beverage.Cost() + 0.50m;<br />}<br /><br />class ChocolateDecorator : IAdditionDecorator<br />{<br />    public ChocolateDecorator(IBeverage beverage)<br />    {<br />        Beverage = beverage;<br />    }<br /><br />    public IBeverage Beverage { get; set; }<br /><br />    public decimal Cost() => Beverage.Cost() + 0.74m;<br />}<br />```<br /><br />**In TypeScript:**<br />```ts<br />> Class decorators<br /><br />    function log(constructor: any) {<br />        console.log(`New ${constructor.name} created!`)<br />    }<br />    <br />    @log<br />    class Yogurt {<br />        <br />        public flavor: string;<br />    <br />        constructor(flavor: string) {<br />            this.flavor = flavor<br />        }<br />    }<br /><br />> Method decorators<br /><br />    import userModel from './user.model'<br />    import UserNotFoundException from './UserNotFoundException'<br />    <br />    function excludeProperties(propertiesToExclude: string[]) {<br />        return (target: any, propertyName: string, descriptor: PropertyDescriptor) =&gt {<br />            const originalFunction = descriptor.value<br />            <br />            descriptor.value = async function(...args: any[]) {<br />                const originalResult = await originalFunction.apply(this, args)<br />                propertiesToExclude.forEach(propertyName =&gt {<br />                delete originalResult[propertyName]<br />                })<br />                return originalResult<br />            }<br />        }<br />    }<br />        <br />    class UserService {<br />        private user = userModel<br />        <br />        @excludeProperties(['password'])<br />        private getUser = async (userId: string) => {<br />            const user = await this.user.findById(userId)<br />            if (user) {<br />                return user<br />            }<br />            throw new UserNotFoundException(userId)<br />        }<br />    }<br />```<br /><br />### Composite<br /><br />A tree structure of composite objects and leaf objects.<br /><br />> *Composite pattern is useful with abstractions that can be hierarchically organized.*<br /><br />**Uses:**<br />- DOM<br />- TodoLists<br />- Genealogy<br /><br />**UML:**<br /><br />![composite-pattern](https://user-images.githubusercontent.com/72560319/159482200-4908a097-ae9d-4f25-8f8d-a4ffc76b1395.png)<br /><br />**In C#:**<br />```cs<br />interface ITodoList<br />{<br />	string getHtml();<br />}<br /><br />class Todo : ITodoList<br />{<br />    public Todo(string text)<br />    {<br />        Text = text;<br />    }<br />    <br />    public string Text { get; set; }<br /><br />    public string getHtml() <br />    { <br />        return "<li>" + Text + "</li>"; <br />    }<br />}<br /><br />class Project : ITodoList<br />{<br />    public Project(string title, List<ITodoList> todos)<br />    {<br />        Title = title;<br />        Todos = todos;<br />    }<br />    <br />    public string Title { get; set; }<br />    public List<ITodoList> Todos { get; set; }<br /><br />    public string getHtml() <br />    {<br />        var html = "<h1>" + Title + "</h1>";<br /><br />        html += "<ul>";<br />        Todos.ForEach(t => html += t.getHtml());<br />        html += "</ul>";<br /><br />        return html;<br />    }<br />}<br />```<br /><br />### Flyweight<br /><br />A fine-grained instance used for efficient sharing and memory saving, as if an flyweight object already exists, it will be returned and not created again.<br /><br />**Applicability:**<br />- High memory cost softwares<br />- Optimization<br />- Memory saving<br /><br />## Behavioral Patterns<br /><br />### Chain of Responsibility<br /><br />A way of passing a request between a chain of objects called handlers that pass the request forward until it is solved, similar to middlewares.<br /><br />> This pattern can be used when it's needed to execute several handlers in a particular order and handlers need to be eated dynamically.<br /><br />> Chain of responsability pattern is useful to apply Single Responsability principle,  to structure your code with an business rule, to make it easy to add features and to alter these responsabilities without affecting the others.<br /><br />**Uses:**<br />- HTTP Requisitions<br />- Finances<br />- Validators<br />- Attendance Chain<br />- Rules Engine<br /><br />**UML:**<br /><br />![chain-of-responsability](https://user-images.githubusercontent.com/72560319/159990391-5a84726d-1cde-4838-a199-1db692df49ed.png)<br /><br />**In C#:**<br />```cs<br />// Client<br />class Attendance<br />{<br />    public void Treat(Call call)<br />    {<br />        var handler = new SalesHandler();<br />        handler<br />            .SetNextHandler(new RefoundHandler())<br />            .SetNextHandler(new MarketingHandler())<br />            .SetNextHandler(new OtherHandler());<br /><br />        handler.Handle(call);<br />    }<br />}<br /><br /><br />// Request<br />class Call<br />{<br />    public Call(uint option)<br />    {<br />        Option = option;<br />    }<br /><br />    public uint Option { get; set; }<br />    public bool Solved { get; set; }<br />}<br /><br />// Handlers<br />abstract class BaseHandler<br />{<br />    protected BaseHandler? _nextHandler { get; set; }<br /><br />    public BaseHandler SetNextHandler(BaseHandler nextHandler)<br />    {<br />        _nextHandler = nextHandler;<br />        return _nextHandler;<br />    }<br /><br />    public virtual Call Handle(Call call)<br />    {<br />        if (_nextHandler == null)<br />            return call;<br /><br />        return _nextHandler.Handle(call);<br />    }<br />}<br /><br />class SalesHandler : BaseHandler<br />{<br />    public override Call Handle(Call call)<br />    {<br />        if (call.Option == 1)<br />        {<br />            Console.WriteLine("Forwarding your call to Sales...");<br />            call.Solved = true;<br />            return call;<br />        }<br /><br />        return base.Handle(call);<br />    }<br />}<br /><br />class RefoundHandler : BaseHandler<br />{<br />    public override Call Handle(Call call)<br />    {<br />        if (call.Option == 2)<br />        {<br />            Console.WriteLine("Forwarding your call to Refound...");<br />            call.Solved = true;<br />            return call;<br />        }<br /><br />        return base.Handle(call);<br />    }<br />}<br /><br />class MarketingHandler : BaseHandler<br />{<br />    public override Call Handle(Call call)<br />    {<br />        if (call.Option == 3)<br />        {<br />            Console.WriteLine("Forwarding your call to Marketing...");<br />            call.Solved = true;<br />            return call;<br />        }<br /><br />        return base.Handle(call);<br />    }<br />}<br /><br />class OtherHandler : BaseHandler<br />{<br />    public override Call Handle(Call call)<br />    {<br />        Console.WriteLine("Forwarding your call to another sector...");<br />        call.Solved = true;<br />        return call;<br />    }<br />}<br />```<br /><br />### Command<br /><br />Encapsulates a command request as an object, supporting undoable operations.<br /><br />> With this pattern, instead of just perform some action, it's possible to wrap that action in a command and make sure it is undoable.<br /><br />**Uses:**<br />- Automation<br />- Request Queues<br />- Editors<br />- Do & Undo Operations<br />- Macro Commands<br /><br />**UML:**<br /><br />![command](https://user-images.githubusercontent.com/72560319/159564163-dc0e989b-49e8-4fda-9c7b-b0e0f7e3f1b9.png)<br /><br />**In C#:**<br />```cs<br />public class Program<br />{<br />    public static void Main()<br />    {<br />        var receiver = new Light();<br />        var invoker = new RemoteControl(<br />                        new LightOnCommand(receiver),<br />                        new LightOnCommand(receiver),<br />                        new LightOffCommand(receiver),<br />                        new LightOffCommand(receiver)<br />                      );<br />    }<br />}<br /><br />class RemoteControl // Invoker<br />{<br />    public RemoteControl(ICommand on, ICommand up, ICommand down, ICommand off)<br />    {<br />        On = on;<br />        Up = up;<br />        Down = down;<br />        Off = off;<br />    }<br /><br />    private ICommand On { get; set; }<br />    private ICommand Up { get; set; }<br />    private ICommand Down { get; set; }<br />    private ICommand Off { get; set; }<br /><br />    public void ClickOn() => On.Execute();<br />    public void ClickOff() => Off.Execute();<br />}<br /><br />interface ICommand<br />{<br />    void Execute();<br />    void Unexecute();<br />}<br /><br />class LightOnCommand : ICommand<br />{<br />    public LightOnCommand(Light light)<br />    {<br />        Light = light;<br />    }<br /><br />    public Light Light { get; set; }<br /><br />    public void Execute() => Light.On();<br />    public void Unexecute() => Light.Off();<br />}<br /><br />class LightOffCommand : ICommand<br />{<br />    public LightOffCommand(Light light)<br />    {<br />        Light = light;<br />    }<br /><br />    public Light Light { get; set; }<br /><br />    public void Execute() => Light.Off();<br />    public void Unexecute() => Light.On();<br />}<br /><br />class Light // Receiver<br />{<br />    public void On() { }<br />    public void Off() { }<br />}<br />```<br /><br />### Interpreter<br /><br />A way to include language elements in a program.<br /><br />### Iterator<br /><br />Sequentially access the elements of a collection, without exposing its underlying representation, that is, not exposing all the items right away.<br /><br />> Some benefits of iterator pattern is that is possible to create infinite collections and to pause the iteration to continue it later in a much easier way than `foreach`s with an index.<br /><br />**Uses:**<br />- Custom Collections<br />- Games<br /><br />**UML:**<br /><br />![iterator](https://user-images.githubusercontent.com/72560319/159944504-30077262-791e-433d-80c7-f25f24322081.png)<br /><br />**In C#:**<br />```cs<br />public class Program<br />{<br />    public static void Main()<br />    {<br />        var handHeldInventory = new HandHeldInventory(new FoodItem(1, "Apple", 20.00), new WeaponIem(2, "Sword", 60.00));<br />        var handItor = handHeldInventory.GetIterator();<br /><br />        while (!handItor.IsDone()) // Abstraction<br />        {<br />            Console.WriteLine(handItor.Current());<br />            handItor.Next();<br />        }        <br />        <br />        var backpackInventory = new BackpackInventory(new FoodItem(1, "Apple", 20.00), new FoodItem(1, "Bread", 40.00), new WeaponIem(2, "Sword", 60.00));<br />        var backpackItor = backpackInventory.GetIterator();<br /><br />        while (!backpackItor.IsDone()) // Same abstraction<br />        {<br />            Console.WriteLine(backpackItor.Current());<br />            backpackItor.Next();<br />        }<br />    }<br />}<br /><br />// Items<br />interface IItem<br />{<br />    uint Id { get; set; }<br />    string Name { get; set; }<br />}<br /><br />class FoodItem : IItem<br />{<br />    public FoodItem(uint id, string name, double regeneration)<br />    {<br />        Id = id;<br />        Name = name;<br />        Regeneration = regeneration;<br />    }<br /><br />    public uint Id { get; set; }<br />    public string Name { get; set; }<br />    public double Regeneration { get; set; }<br />}<br /><br />class WeaponIem : IItem<br />{<br />    public WeaponIem(uint id, string name, double damage)<br />    {<br />        Id = id;<br />        Name = name;<br />        Damage = damage;<br />    }<br /><br />    public uint Id { get; set; }<br />    public string Name { get; set; }<br />    public double Damage { get; set; }<br />}<br /><br />// Iterables<br />interface IInventory<br />{<br />    IInventoryIterator GetIterator();<br />}<br /><br />class HandHeldInventory : IInventory<br />{<br />    public HandHeldInventory(IItem leftItem, IItem rightItem)<br />    {<br />        LeftItem = leftItem;<br />        RightItem = rightItem;<br />    }<br /><br />    public IItem LeftItem { get; set; }<br />    public IItem RightItem { get; set; }<br /><br />    public IInventoryIterator GetIterator() => new HandHeldInventoryIterator(this); // Factory Method<br />}<br /><br />class BackpackInventory : IInventory<br />{<br />    public BackpackInventory(IItem item1, IItem item2, IItem item3)<br />    {<br />        Item1 = item1;<br />        Item2 = item2;<br />        Item3 = item3;<br />    }<br /><br />    public IItem Item1 { get; set; }<br />    public IItem Item2 { get; set; }<br />    public IItem Item3 { get; set; }<br />    // ...<br /><br />    public IInventoryIterator GetIterator() => new HandHeldInventoryIterator(this); // Factory Method<br />}<br /><br />// Iterators<br />interface IInventoryIterator<br />{<br />    bool IsDone();<br />    void Next();<br />    IItem? Current();<br />}<br /><br />class HandHeldInventoryIterator : IInventoryIterator<br />{<br />    public HandHeldInventoryIterator(HandHeldInventory inventory)<br />    {<br />        _inventory = inventory;<br />    }<br /><br />    private HandHeldInventory _inventory { get; set; } // Iterable<br />    private uint _index = 0;<br /><br />    public bool IsDone() => _index < 2;<br />    public void Next() => _index++;<br />    public IItem? Current()<br />    {<br />        switch (_index)<br />        {<br />            case 0:<br />                return _inventory.LeftItem;<br />            case 1:<br />                return _inventory.RightItem;<br />            default:<br />                return null;<br />        }<br />    }<br />}<br /><br />class BackpackInventoryIterator : IInventoryIterator<br />{<br />    public BackpackInventoryIterator(BackpackInventory inventory)<br />    {<br />        _inventory = inventory;<br />    }<br /><br />    private BackpackInventory _inventory { get; set; } // Iterable<br />    private uint _index = 0;<br /><br />    public bool IsDone() => _index < 3;<br />    public void Next() => _index++;<br />    public IItem? Current()<br />    {<br />        switch (_index)<br />        {<br />            case 0:<br />                return _inventory.Item1;<br />            case 1:<br />                return _inventory.Item2;<br />            case 2:<br />                return _inventory.Item3;<br />            default:<br />                return null;<br />        }<br />    }<br />}<br />```<br />#### Null Iterator<br /><br />> *For better undestanding, check the [Null Object Pattern](#null-object)*.<br /><br />Defines an always null iterator.<br /><br />**Uses:**<br />- Component Leaves (Composite Pattern)<br />- Null States (State Pattern)<br /><br />**In C#:**<br />```cs<br />class NullIterator : IIterator<br />{<br />    public NullIterator(IIterable iterable)<br />    {<br />        _iterable = iterable;<br />    }<br /><br />    private IIterable _iterable { get; set; }<br />    private uint _index = 0;<br /><br />    public bool IsDone() => true;<br />    public void Next() { }<br />    public IItem? Current() => null;<br />}<br />```<br /><br />### Mediator<br /><br />Defines simplified communication between classes.<br /><br />### Memento<br /><br />Capture and restore an object's internal state.<br /><br />### State<br /><br />Alter an object's behavior at runtime when its internal state changes.<br /><br />> The state is not an enum or property, it is an object. Therefore, it replaces a conditional with polymorphism.<br /><br />**Uses:**<br />- Network Requests<br />- UI Components<br />- No-Memory Machines<br /><br />![state-example](https://user-images.githubusercontent.com/72560319/159712767-c29a028c-22a5-4be6-9a2d-7390e533e2a8.png)<br /><br />**UML:**<br /><br />![state](https://user-images.githubusercontent.com/72560319/159712692-cf90884f-1bee-475d-94d7-e02a630e9bec.png)<br /><br />**In C#:**<br />```cs<br />class Gate<br />{<br />    public Gate(IGateState initialState)<br />    {<br />        State = initialState;<br />    }<br /><br />    public IGateState State { get; set; }<br /><br />    public void Enter() => State = State.Enter(); <br />    public void Pay() => State = State.Pay(); <br />    public void PayOk() => State = State.PayOk(); <br />    public void PayFailed() => State = State.PayFailed(); <br />}<br /><br />interface IGateState<br />{<br />    IGateState Enter();<br />    IGateState Pay();<br />    IGateState PayOk();<br />    IGateState PayFailed();<br />}<br /><br />class ClosedGateState : IGateState<br />{<br />    public IGateState Enter() => new ClosedGateState();<br />    public IGateState Pay() => new ProcessingPaymentGateState();<br />    public IGateState PayOk() => new ClosedGateState();<br />    public IGateState PayFailed() => new ClosedGateState();<br />}<br /><br />class ProcessingPaymentGateState : IGateState<br />{<br />    public IGateState Enter() => new ProcessingPaymentGateState();<br />    public IGateState Pay() => new ProcessingPaymentGateState();<br />    public IGateState PayOk() => new OpenGateState();<br />    public IGateState PayFailed() => new ClosedGateState();<br />}<br /><br />class OpenGateState : IGateState<br />{<br />    public IGateState Enter() => new ClosedGateState();<br />    public IGateState Pay() => new OpenGateState();<br />    public IGateState PayOk() => new OpenGateState();<br />    public IGateState PayFailed() => new OpenGateState();<br />}<br />```<br /><br />### Observer<br /><br />Defines an one to many dependency between objects, so that when the observable changes state all of its dependecies are notified and updated automatically.<br /><br />> *The observable is the object that changes and the observers are the objects interested in the observable changes.*<br /><br />**Uses:**<br />- Chats<br />- Sensors<br />- Newsletters<br />- Notifications<br /><br />**UML:**<br /><br />![observer](https://user-images.githubusercontent.com/72560319/159771101-5af99680-3192-430e-ac3e-ff87cc54c350.png)<br /><br />**In C#:**<br />```cs<br />public class Program<br />{<br />	public static void Main()<br />	{<br />		var station = new WeatherStation();<br />		station.Add(new PhoneDisplay(station));<br />		station.Add(new WindowDisplay(station));<br />	}<br />}<br /><br />interface IObservable<br />{<br />    List<IObserver> Observers { get; }<br /><br />    void Add(IObserver observer);<br />    void Remove(IObserver observer);<br />    void Notify();<br />}<br /><br />class WeatherStation : IObservable<br />{<br />    public WeatherStation()<br />    {<br />        Observers = new List<IObserver> { };<br />    }<br /><br />    public List<IObserver> Observers { get; private set; }<br /><br />    private decimal _temperature { get; set; }<br />    public decimal Temperature<br />    {<br />        get => _temperature;<br />        set <br />        { <br />            _temperature = value;<br />            Notify();<br />        }<br />    }<br /><br />    private decimal _humidity { get; set; }<br />    public decimal Humidity<br />    {<br />        get => _humidity;<br />        set<br />        {<br />            _humidity = value;<br />            Notify();<br />        }<br />    }<br /><br />    public void Add(IObserver observer) => Observers.Add(observer);<br />    public void Remove(IObserver observer) => Observers.Remove(observer);<br />    public void Notify() => Observers.ForEach(o => o.Update());<br />}<br /><br />interface IObserver<br />{<br />    void Update();<br />}<br /><br />class PhoneDisplay : IObserver<br />{<br />    public PhoneDisplay(WeatherStation station)<br />    {<br />        Station = station;<br />    }<br /><br />    public WeatherStation Station { get; init; }<br />    public decimal Temperature { get; private set; } // Only this state matters for this object<br /><br />    public void Update() <br />    {<br />        if (Temperature != Station.Temperature)<br />        {<br />            Temperature = Station.Temperature;<br />            Display();<br />        }<br />    }<br /><br />    public void Display() { } // Refreshes temperature on display<br />}<br /><br />class WindowDisplay : IObserver<br />{<br />    public WindowDisplay(WeatherStation station)<br />    {<br />        Station = station;<br />    }<br /><br />    public WeatherStation Station { get; init; }<br />    public decimal Humidity { get; private set; } // Only this state matters for this object<br /><br />    public void Update()<br />    {<br />        if (Humidity != Station.Humidity)<br />        {<br />            Humidity = Station.Humidity;<br />            Display();<br />        }<br />    }<br /><br />    public void Display() { } // Refreshes humidity on display<br />}<br />```<br /><br />### Strategy<br /><br />Encapsulates an algorithm inside a class and allows that a class behavior or its algorithm can be changed at runtime.<br /><br />> *The strategy pattern is about using composition and dependency injection instead of inheritance.*<br /><br />> *This pattern is useful to encapsulate business rules, once it can remove the need of subclasses and transform abstract classes into normal classes.*<br /><br />**Uses:**<br />- Ecommerces<br />- Finances<br />- Law<br /><br />**UML:**<br /><br />![strategy](https://user-images.githubusercontent.com/72560319/159779934-01d3c83e-a469-4b82-812f-d52cb7e443fb.png)<br /><br />**In C#:**<br />```cs<br />public class Program<br />{<br />    public static void Main()<br />    {<br />        var cityDuck = new Duck(new SimpleQuacking(), new SimpleFlying(), new DisplayAsText());<br />        var wildDuck = new Duck(new SimpleQuacking(), new JetFlying(), new DisplayAsGraphics());<br />        var mountainDuck = new Duck(new SimpleQuacking(), new JetFlying(), new DisplayAsText());<br />        var rubberDuck = new Duck(new NoQuacking(), new SimpleFlying(), new DisplayAsGraphics());<br />    }<br />}<br /><br />class Duck<br />{<br />    public Duck(IQuackBehaviour quackBehaviour, IFlyBehaviour flyBehaviour, IDisplayBehaviour displayBehaviour)<br />    {<br />        QuackBehaviour = quackBehaviour;<br />        FlyBehaviour = flyBehaviour;<br />        DisplayBehaviour = displayBehaviour;<br />    }<br /><br />    public IQuackBehaviour QuackBehaviour { get; set; }<br />    public IFlyBehaviour FlyBehaviour { get; set; }<br />    public IDisplayBehaviour DisplayBehaviour { get; set; }<br /><br />    public void Quack() => QuackBehaviour.Quack();<br />    public void Fly() => FlyBehaviour.Fly();<br />    public void Display() => DisplayBehaviour.Display();<br />}<br /><br />interface IQuackBehaviour<br />{<br />    void Quack();<br />}<br /><br />class SimpleQuacking : IQuackBehaviour<br />{<br />    public void Quack()<br />    {<br />        // Logic<br />    }<br />}<br /><br />class NoQuacking : IQuackBehaviour<br />{<br />    public void Quack()<br />    {<br />        // Logic<br />    }<br />}<br /><br />interface IFlyBehaviour<br />{<br />    void Fly();<br />}<br /><br />class SimpleFlying : IFlyBehaviour<br />{<br />    public void Fly()<br />    {<br />        // Logic<br />    }<br />}<br /><br />class JetFlying : IFlyBehaviour<br />{<br />    public void Fly()<br />    {<br />        // Logic<br />    }<br />}<br /><br />interface IDisplayBehaviour<br />{<br />    void Display();<br />}<br /><br />class DisplayAsText : IDisplayBehaviour<br />{<br />    public void Display()<br />    {<br />        // Logic<br />    }<br />}<br /><br />class DisplayAsGraphics : IDisplayBehaviour<br />{<br />    public void Display()<br />    {<br />        // Logic<br />    }<br />}<br />```<br /><br />### Template Method<br /><br />Defer the exact steps of an algorithm to a subclass, working as a blueprint for methods.<br /><br />> *Template method pattern works better in cases where strategy doesn't fit and there is fixed logic on the template. Anyway, it can be very dangerous given that it uses inheritance over composition.*<br /><br />> *A template method class is composed by a defined method (template method) and the empty methods (hooks) that are called inside the template method.*<br /><br />> *This pattern is similitar to inversion of dependency pattern, like the Hollywood principle: "Don't call us, we'll call you. Or not."* <br /><br />**Uses:**<br />- Frameworks<br />- Database Operations<br /><br />**UML:**<br /><br />![template-method](https://user-images.githubusercontent.com/72560319/159915346-6633ca6f-0198-43cb-b041-3090c50ebe83.png)<br /><br />**In C#:**<br />```cs<br />abstract class Record<br />{<br />    public void Save()<br />    {<br />        Validate();<br />        BeforeSave();<br />        // Save to DB<br />        AfterSave();<br />    }<br /><br />    // Hooks<br />    public virtual void Validate() { }<br />    public virtual void BeforeSave() { }<br />    public virtual void AfterSave() { }<br />}<br /><br />class UserRecord : Record<br />{<br />    public override void Validate()<br />    {<br />        // Logic<br />    }<br /><br />    public override void BeforeSave()<br />    {<br />        // Logic<br />    }<br />}<br /><br />class PostRecord : Record<br />{<br />    public override void Validate()<br />    {<br />        // Logic<br />    }<br /><br />    public override void AfterSave()<br />    {<br />        // Logic<br />    }<br />}<br />```<br /><br />### Visitor<br /><br />Defines a new operation to a class without change.<br /><br />## Other Patterns<br /><br />### Null Object<br /><br />Designed to act as a default value of an object, working as a null state.<br /><br />> *This pattern make it possible to handle nullness in the same way that somethingness is handled.*<br /><br />### Honorable Mentions<br /><br />-   **Dependency Injection**<br />-   **Inversion of Control**<br />-   **Inversion of Dependency**<br />-   **Lazy Loading**<br />-   **Object Pool:** avoid expensive acquisition and release of resources by recycling objects that are no longer in use<br />- **Private Class Data:** restricts accessor/mutator access.<br />-   **Mock Object**<br />-   **Rules Design Patterns**<br />-   **Intercepting Filter**<br />-   **Method Chaining**<br />-   **Unit of Work**<br /><br />|

<!--stackedit_data:
eyJoaXN0b3J5IjpbMjkxNTM3MTYxXX0=
-->